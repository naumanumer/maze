{"version":3,"file":"main.es.js","sources":["../../src/utils/point.ts","../../src/utils/cellSet.ts","../../src/utils/h/svgTags.ts","../../src/utils/h/index.ts","../../src/utils/array.ts","../../src/generators/_pathSetGenerator.ts","../../src/generators/utils.ts","../../src/generators/index.ts","../../src/generators/recursiveBackTrack.ts","../../src/generators/aldousBroder.ts","../../src/generators/binaryTree.ts","../../src/generators/eller.ts","../../src/generators/kruskal.ts","../../src/generators/huntAndKill.ts","../../src/generators/primsRandomization.ts","../../src/generators/wilson.ts","../../src/generators/sidewinder.ts","../../src/board/cell.ts","../../src/board/board.ts","../../src/board/_.ts","../../src/renderers/rectangularSvg.tsx","../../src/renderers/index.ts","../../src/player/index.ts","../../src/main.ts","../../src/game/index.ts","../../src/browser/element/index.ts","../../src/browser/keyboard/index.ts","../../src/browser/touch/index.ts"],"sourcesContent":["export interface Position {\n  readonly x: number;\n  readonly y: number;\n}\n\n/**\n * Convert a position (2d) to linear index\n */\nexport function positionToIndex(position: Position, width: number): number {\n  return position.y * width + position.x;\n}\n\nexport function stringifyPosition(position: Position) {\n  return `${position.x}-${position.y}`;\n}\n","import {Cell} from \"../board\";\nimport {stringifyPosition} from \"./point\";\n\nexport class CellSet extends Map<string, Cell> {\n  constructor(cells?: Cell[]) {\n    super();\n\n    if (cells) this.addAll(cells);\n  }\n\n  add(cell: Cell) {\n    return this.set(stringifyPosition(cell.position), cell);\n  }\n\n  addAll(cells: Cell[]) {\n    for (let cell of cells)\n      this.add(cell);\n  }\n\n  hasCell(cell: Cell) {\n    return this.has(stringifyPosition(cell.position));\n  }\n\n  remove(cell: Cell) {\n    return this.delete(stringifyPosition(cell.position));\n  }\n\n  removeAll(cells: Cell[]) {\n    for (let cell of cells)\n      this.remove(cell);\n  }\n\n  getRandom(): Cell {\n    const cells = Array.from(this.values());\n    return cells[Math.round(Math.random() * (cells.length -1))];\n  }\n}\n","export default [\"circle\", \"defs\", \"ellipse\", \"filter\", \"g\", \"line\", \"path\", \"rect\", \"svg\"]\n","/*\n * Adopted from https://github.com/squidfunk/mkdocs-material/blob/master/src/assets/javascripts/utilities/h/index.ts\n * with additional support for svg elements\n */\n\nimport {JSX as JSXInternal} from \"preact\"\nimport svgTags from \"./svgTags\";\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes =\n  & JSXInternal.HTMLAttributes\n  & JSXInternal.SVGAttributes\n  & Record<string, any>\n\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nfunction appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory\n *\n * @param tag - HTML tag\n * @param attributes - HTML attributes\n * @param children - Child elements\n *\n * @returns Element\n */\nexport function h(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(attr, attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(attr, \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n\n\n/* This override is necessary for types to work */\nexport declare namespace h {\n  namespace JSX {\n    type Element = HTMLElement\n    type IntrinsicElements = JSXInternal.IntrinsicElements\n  }\n}\n","export function shuffle(array: any[]) {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import {Cell} from \"../board\";\nimport {CellSet} from \"../utils/cellSet\";\nimport set = Reflect.set;\n\nexport type PathSet = Record<string, Cell>;\n\nexport abstract class PathSetGenerator {\n  protected getSetFromCell(cell: Cell, pathSets: CellSet[]): CellSet | undefined {\n    for (let set of pathSets) {\n      if (set.hasCell(cell)) {\n        return set;\n      }\n    }\n  }\n\n  protected joinCellSets(cell1: Cell, cell2: Cell, pathSets: CellSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    if (!set1 && !set2) {\n      pathSets.push(new CellSet([cell1, cell2]));\n    } else if (set1 == null) {\n      set2.add(cell1);\n    } else if (set2 == null) {\n      set1.add(cell2);\n    } else {\n      set1.addAll(Array.from(set2.values()));\n      const i = pathSets.indexOf(set2);\n      pathSets.splice(i, 1);\n    }\n  }\n\n  protected isFromSameSet(cell1: Cell, cell2: Cell, pathSets: CellSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    return !!set1 && !!set2 && set1 == set2;\n  }\n}\n","import {Board, Cell} from \"../board\";\nimport {stringifyPosition} from \"../utils\";\nimport {CellSet} from \"../utils/cellSet\";\n\nexport function getUnvisitedCell(board: Board, visitedCells: CellSet) {\n  for (let cell of board.cells) {\n    if (!visitedCells.has(stringifyPosition(cell.position))) {\n      return cell;\n    }\n  }\n}\n\nexport function getRandomFrom<T>(list: T[]): T {\n  return list[Math.round(Math.random() * (list.length - 1))];\n}\n\nexport function getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\n// may be we should move it somewhere else\n// wilson, hunt&kill, aldousBroder, backtrack\n/**\n * Do a random walk in the board until some condition is fulfilled\n */\nexport function randomWalkUntil(\n  cell: Cell,\n  board: Board,\n  until: (cell: Cell, path: Cell[]) => boolean,\n  visitedCells: CellSet = null,\n  path: Cell[] = [],\n): Cell[] {\n  while (until(cell, path)) {\n    path.push(cell);\n    let neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n    if (visitedCells) {\n      neighbourCells = neighbourCells.filter((cell) => {\n        return !visitedCells.hasCell(cell);\n      })\n    }\n    cell = getRandomFrom(neighbourCells);\n  }\n\n  path.push(cell);\n  return path;\n}\n","import RecursiveBacktrack from \"./recursiveBackTrack\";\nimport AldousBroder from \"./aldousBroder\";\nimport BinaryTree from \"./binaryTree\";\nimport Eller from \"./eller\";\nimport Kruskal from \"./kruskal\";\nimport HuntAndKill from \"./huntAndKill\";\nimport PrimsRandomization from \"./primsRandomization\";\nimport {Wilson} from \"./wilson\";\nimport {Sidewinder} from \"./sidewinder\";\n\nexport * from './types';\n\nexport const Generators = {\n  RecursiveBackTrack: new RecursiveBacktrack(),\n  AldousBroder: new AldousBroder(),\n  BinaryTree: new BinaryTree(),\n  Eller: new Eller(),\n  Kruskal: new Kruskal(),\n  HuntAndKill: new HuntAndKill(),\n  PrimsRandomization: new PrimsRandomization(),\n  Wilson: new Wilson(),\n  Sidewinder: new Sidewinder(),\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * Depth first recursive backtrack maze generation algorithm\n * https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n *\n * Generates long dead ends making the solution little difficult\n */\nexport default class RecursiveBacktrack implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    const randomCell = board.getRandomCell();\n\n    this.visitCell(randomCell, visitedCells, board);\n    return board;\n  }\n\n  visitCell(cell: Cell, visitedCells: CellSet, board: Board) {\n    visitedCells.add(cell);\n    const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n\n    while (neighbourCells.length !== 0) {\n      // select a random neighbour\n      const i = Math.round(Math.random() * (neighbourCells.length - 1));\n      const randomCell = neighbourCells[i];\n\n      // if random neighbour is not already visited remove wall between\n      // random neighbour and current cell and recursively visit that neighbour\n      if (!visitedCells.hasCell(randomCell)) {\n        board.removeInterWall(cell.position, randomCell.position);\n        this.visitCell(randomCell, visitedCells, board);\n      }\n\n      // after visit remove random neighbour from neighbourCells\n      neighbourCells.splice(i, 1);\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm\n */\nexport default class AldousBroder implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    let currentCell = board.getRandomCell();\n    const visitedCells = new CellSet();\n    visitedCells.add(currentCell);\n\n    let movingTowards;\n\n    while (visitedCells.size < board.size.height * board.size.width) {\n      const cellNeighbours = Array.from(board.getNeighbourCells(currentCell.position).values());\n\n      const unvisitedNeighbours = cellNeighbours.filter((cell) => {\n        return !visitedCells.hasCell(cell);\n      })\n\n      // If there are some unvisited neighbours choose any random neighbour and visit it\n      if (unvisitedNeighbours.length > 0) {\n        let randomCell = cellNeighbours[Math.round((cellNeighbours.length - 1) * Math.random())];\n        if (!visitedCells.hasCell(randomCell)) {\n          board.removeInterWall(randomCell.position, currentCell.position)\n          visitedCells.add(randomCell);\n          movingTowards = null;\n        }\n\n        currentCell = randomCell;\n      } else {\n        // else just find random unvisited cell and move towards that cell\n        // until you hit some cell which has some unvisited neighbours\n        // NOTE: its not from actual algorithm but doing make this algorithm to always end in finite time\n\n        if (!movingTowards) {\n          const unvisitedCells = board.cells.filter((cell) => {\n            return !visitedCells.hasCell(cell);\n          });\n\n          movingTowards = unvisitedCells[Math.round((unvisitedCells.length - 1) * Math.random())]\n        }\n\n        let dx = Math.sign(movingTowards.position.x - currentCell.position.x);\n        let dy = dx === 0 ? Math.sign(movingTowards.position.y - currentCell.position.y) : 0;\n        currentCell = board.getCell({x: currentCell.position.x + dx, y: currentCell.position.y + dy});\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\n\n/**\n * http://weblog.jamisbuck.org/2011/2/1/maze-generation-binary-tree-algorithm\n */\nexport default class BinaryTree implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const topBias = Math.random() > 0.5;\n    const rightBias = Math.random() > 0.5;\n\n    for (let currentCell of board.cells) {\n      let neighbourCells = Array.from(board.getNeighbourCells(currentCell.position).values());\n      neighbourCells = neighbourCells.filter((cell) => {\n        const dir = board.getRelativeDirection(currentCell.position, cell.position);\n\n        return (rightBias && dir == RectangularDirection.LEFT) ||\n          (!rightBias && dir == RectangularDirection.RIGHT) ||\n          (topBias && dir == RectangularDirection.DOWN) ||\n          (!topBias && dir == RectangularDirection.UP);\n      });\n\n      if (neighbourCells.length > 0) {\n        const randomCell = neighbourCells[Math.round((neighbourCells.length - 1) * Math.random())];\n        board.removeInterWall(randomCell.position, currentCell.position)\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {shuffle} from \"../utils\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport default class Eller extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: CellSet[] = [];\n\n    for (let x = 0; x < board.size.width; x++) {\n      const cell = board.getCell({x, y: 0});\n      pathSets.push(new CellSet([cell]));\n    }\n\n    for (let y = 0; y < board.size.height - 1; y++) {\n      this.visitRow(y, false, board, pathSets);\n      this.visitNextRow(y, board, pathSets);\n    }\n\n    this.visitRow(board.size.height - 1, true, board, pathSets);\n    return board;\n  }\n\n  private visitRow(index: number, mergeAll: boolean, board: Board, pathSets: CellSet[]) {\n    for (let x = 1; x < board.size.width; x++) {\n      const cell1 = board.getCell({y: index, x: x - 1});\n      const cell2 = board.getCell({y: index, x});\n\n      if (this.isFromSameSet(cell1, cell2, pathSets)) {\n        continue;\n      }\n\n      if (Math.random() > 0.5 || mergeAll) {\n        board.removeInterWall(cell1.position, cell2.position);\n        this.joinCellSets(cell1, cell2, pathSets);\n      } else if (this.getSetFromCell(cell1, pathSets) == null) {\n        pathSets.push(new CellSet([cell1]));\n      } else if (this.getSetFromCell(cell2, pathSets) == null) {\n        pathSets.push(new CellSet([cell2]));\n      }\n    }\n  }\n\n  private visitNextRow(index: number, board: Board, pathSets: CellSet[]) {\n    for (let set of pathSets) {\n      let setCells = Array.from(set.entries())\n        .filter(([key, cell]) => {\n          return cell.position.y === index;\n        })\n        .map(([key, cell]) => cell);\n\n      setCells = shuffle(setCells);\n      let n = 1 + Math.round(Math.random() * (setCells.length - 1));\n      for (let i = 0; i < n; i++) {\n        const cell = setCells[i];\n        const nextCell = board.getCell({x: cell.position.x, y: cell.position.y + 1});\n\n        board.removeInterWall(cell.position, nextCell.position);\n        set.add(nextCell);\n      }\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm\n */\nexport default class Kruskal extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: CellSet[] = [];\n\n    for (let cell of board.cells) {\n      pathSets.push(new CellSet([cell]));\n    }\n\n    while (pathSets.length > 1) {\n      const randomCell = board.getRandomCell();\n      const neighbours = Array.from(board.getNeighbourCells(randomCell.position).values());\n      const randomNeighbour = neighbours[Math.round((neighbours.length - 1) * Math.random())]\n\n      if (this.isFromSameSet(randomCell, randomNeighbour, pathSets)) continue;\n\n      board.removeInterWall(randomCell.position, randomNeighbour.position);\n      this.joinCellSets(randomCell, randomNeighbour, pathSets);\n    }\n\n    return board;\n  }\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {stringifyPosition} from \"../utils\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {getUnvisitedCell, randomWalkUntil} from \"./utils\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/24/maze-generation-hunt-and-kill-algorithm\n */\nexport default class HuntAndKill extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    let cell = getUnvisitedCell(board, visitedCells);\n    visitedCells.add(cell);\n\n    while (cell) {\n      const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n      for (let neighbourCell of neighbourCells) {\n        if (visitedCells.hasCell(neighbourCell)) {\n          board.removeInterWall(cell.position, neighbourCell.position);\n\n          let path = randomWalkUntil(cell, board, (cell, path) => {\n            visitedCells.add(cell);\n            let neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n            return neighbourCells.some((cell) => {\n              return !visitedCells.hasCell(cell);\n            })\n          }, visitedCells);\n\n          // remove wall between cells of path\n          for (let i = 1; i < path.length; i++) {\n            board.removeInterWall(path[i - 1].position, path[i].position);\n          }\n\n          break;\n        }\n      }\n\n      cell = getUnvisitedCell(board, visitedCells);\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * Prim's Randomization Algorithm\n * http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm\n *\n * Generates relatively easy to solve mazes with short dead ends\n */\nexport default class PrimsRandomization implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    let randomCell = board.getRandomCell();\n    const neighbourCells = new CellSet(Array.from(board.getNeighbourCells(randomCell.position).values()));\n\n    visitedCells.add(randomCell);\n\n    while (neighbourCells.size > 0) {\n      randomCell = neighbourCells.getRandom();\n      const randomCellNeighbours = new CellSet(Array.from(board.getNeighbourCells(randomCell.position).values()));\n\n      for (let randomCellNeighbour of randomCellNeighbours.values()) {\n        if (visitedCells.hasCell(randomCellNeighbour)) {\n          board.removeInterWall(randomCellNeighbour.position, randomCell.position);\n\n          neighbourCells.remove(randomCell);\n          visitedCells.add(randomCell);\n          neighbourCells.addAll(Array.from(randomCellNeighbours.values()));\n          neighbourCells.removeAll(Array.from(visitedCells.values()));\n          break;\n        }\n      }\n    }\n\n    return board;\n  }\n}\n","import {MazeGenerator} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {CellSet} from \"../utils/cellSet\";\nimport {getRandomFrom, getUnvisitedCell, randomWalkUntil} from \"./utils\";\n\n/**\n * Wilson's Maze Generation Algorithm\n * https://weblog.jamisbuck.org/2011/1/20/maze-generation-wilson-s-algorithm\n *\n * It unlike many other algorithms generate generate mazes of unbiased complexity\n */\nexport class Wilson implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // mark a random cell a visited\n    const visitedCells = new CellSet();\n    visitedCells.add(board.getRandomCell());\n\n    // loop until not all the cells are visited\n    while (visitedCells.size < board.size.height * board.size.width) {\n      // get a visited cell -- just a fun fact its not random its first unvisited cell ;)\n      let randomCell = getUnvisitedCell(board, visitedCells);\n\n      // make random walk until not reached some visited cell\n      let path = randomWalkUntil(randomCell, board, (cell, path) => {\n        if (path.includes(cell)) {\n          const i = path.indexOf(cell);\n          path.splice(i, path.length);\n        }\n\n        return !visitedCells.hasCell(cell);\n      });\n\n      // remove wall between cells of path\n      for (let i = 1; i < path.length; i++) {\n        board.removeInterWall(path[i - 1].position, path[i].position);\n      }\n\n      // mark all the path cells as visited\n      visitedCells.addAll(path);\n    }\n\n    return board;\n  }\n}\n","import {MazeGenerator} from \"./types\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {getRandomInt} from \"./utils\";\n\n/**\n * https://weblog.jamisbuck.org/2011/2/3/maze-generation-sidewinder-algorithm#\n */\nexport class Sidewinder implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    for (let x = 1; x < board.size.width; x++) {\n      board.removeInterWall({y: 0, x: x}, {y: 0, x: x-1})\n    }\n\n    for (let y = 1; y < board.size.height; y++) {\n      this.visitRow(y, board);\n    }\n\n    return board;\n  }\n\n  private visitRow(y: number, board: Board) {\n    let joinedCells = 0;\n    for (let x = 1; x < board.size.width; x++) {\n      if (Math.random() > .5) {\n        board.removeInterWall({y, x: x - 1}, {y, x})\n        joinedCells++;\n      } else {\n        const h = getRandomInt(x - 1 - joinedCells, x);\n        board.removeInterWall({y, x: h}, {y: y - 1, x: h})\n        joinedCells = 0;\n      }\n    }\n\n    const h = getRandomInt(board.size.width - joinedCells - 1, board.size.width);\n    board.removeInterWall({y, x: h}, {y: y - 1, x: h})\n  }\n}\n","import {Position} from \"../utils\";\n\nexport const enum RectangularDirection {\n  LEFT = 'left',\n  RIGHT = 'right',\n  UP = 'up',\n  DOWN = 'down',\n}\n\nexport const OpposingRectangularDirection = {\n  [RectangularDirection.LEFT]: RectangularDirection.RIGHT,\n  [RectangularDirection.RIGHT]: RectangularDirection.LEFT,\n  [RectangularDirection.UP]: RectangularDirection.DOWN,\n  [RectangularDirection.DOWN]: RectangularDirection.UP,\n};\n\nexport class Cell {\n  public readonly walls: Map<RectangularDirection, boolean>;\n\n  constructor(public readonly position: Position) {\n    this.walls = new Map<RectangularDirection, boolean>();\n    this.setAllWalls();\n  }\n\n  setAllWalls() {\n    this.setWall(RectangularDirection.UP);\n    this.setWall(RectangularDirection.RIGHT);\n    this.setWall(RectangularDirection.DOWN);\n    this.setWall(RectangularDirection.LEFT);\n  }\n\n  removeAllWalls() {\n    this.removeWall(RectangularDirection.UP);\n    this.removeWall(RectangularDirection.RIGHT);\n    this.removeWall(RectangularDirection.DOWN);\n    this.removeWall(RectangularDirection.LEFT);\n  }\n\n  setWall(dir: RectangularDirection) {\n    this.walls.set(dir, true);\n  }\n\n  removeWall(dir: RectangularDirection) {\n    this.walls.set(dir, false);\n  }\n\n  hasWall(dir: RectangularDirection): boolean {\n    return this.walls.get(dir);\n  }\n\n  clone() {\n    const cell = new Cell(this.position);\n    for (const [dir, hasWall] of this.walls.entries()) {\n      cell.walls.set(dir, hasWall);\n    }\n    return cell;\n  }\n}\n","import {Cell, OpposingRectangularDirection, RectangularDirection} from './cell';\nimport {Position, positionToIndex, Size} from \"../utils\";\n\nexport class Board {\n  public readonly cells: Array<Cell>;\n  public readonly size: Size;\n\n  constructor(width: number, height: number) {\n    this.size = {height, width};\n    this.cells = [];\n    this.initCells();\n  }\n\n  private initCells() {\n    for (let y = 0; y < this.size.height; y++) {\n      for (let x = 0; x < this.size.width; x++) {\n        this.cells.push(new Cell({x, y}));\n      }\n    }\n  }\n\n  getRandomCell(): Cell {\n    return this.cells[Math.round(Math.random() * (this.cells.length - 1))];\n  }\n\n  getCell(position: Position): Cell {\n    return this.cells[positionToIndex(position, this.size.width)];\n  }\n\n  getNeighbourCells(position: Position, visitableOnly: boolean = false): Map<RectangularDirection, Cell> {\n    let neighbours = new Map<RectangularDirection, Cell>(),\n      index = positionToIndex(position, this.size.width);\n\n    if (index >= this.size.width) {\n      const cell = this.cells[index - this.size.width];\n      neighbours.set(RectangularDirection.UP, cell);\n    }\n\n    if ((index + 1) % this.size.width != 0) {\n      const cell = this.cells[index + 1];\n      neighbours.set(RectangularDirection.RIGHT, cell);\n    }\n\n    if (index < this.cells.length - this.size.width) {\n      const cell = this.cells[index + this.size.width];\n      neighbours.set(RectangularDirection.DOWN, cell);\n    }\n\n    if (index % this.size.width != 0) {\n      const cell = this.cells[index - 1];\n      neighbours.set(RectangularDirection.LEFT, cell);\n    }\n\n    if (visitableOnly) {\n      const visitableNeighbours = Array.from(neighbours.entries())\n        .filter(([dir, cell]) => {\n          return !this.hasInterWall(cell.position, position);\n        });\n\n      neighbours = new Map(visitableNeighbours);\n    }\n\n    return neighbours;\n  }\n\n  getNeighbourCell(position: Position, direction: RectangularDirection): Cell {\n    const cells = this.getNeighbourCells(position);\n    return cells.get(direction);\n  }\n\n  getRelativeDirection(cell1: Position, cell2: Position): RectangularDirection {\n    if (cell1.y === cell2.y + 1) {\n      return RectangularDirection.UP;\n    }\n    if (cell1.x === cell2.x - 1) {\n      return RectangularDirection.RIGHT;\n    }\n    if (cell1.x === cell2.x + 1) {\n      return RectangularDirection.LEFT;\n    }\n    if (cell1.y === cell2.y - 1) {\n      return RectangularDirection.DOWN;\n    }\n    throw `'${cell1}' and '${cell2}' are not neighbours`;\n  }\n\n  removeInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).removeWall(relativeWallDirection);\n    this.getCell(cell2).removeWall(opposingWallDirection);\n  }\n\n  addInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).setWall(relativeWallDirection);\n    this.getCell(cell2).setWall(opposingWallDirection);\n  }\n\n  hasInterWall(cell1: Position, cell2: Position): boolean {\n    const relativeWall = this.getRelativeDirection(cell1, cell2);\n    const opposingWall = OpposingRectangularDirection[relativeWall];\n    return this.getCell(cell1).hasWall(relativeWall) && this.getCell(cell2).hasWall(opposingWall);\n  }\n\n  isConnected(cell1: Position, cell2: Position): Boolean {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    return this.getCell(cell1).hasWall(relativeWallDirection) && this.getCell(cell2).hasWall(opposingWallDirection);\n  }\n\n  hasWall(position: Position, direction: RectangularDirection) {\n    return this.getCell(position).hasWall(direction);\n  }\n\n  clone() {\n    const board = new Board(this.size.width, this.size.height);\n    for (let i = 0; i < board.cells.length; i++) {\n      board.cells[i] = this.cells[i].clone();\n    }\n    return board;\n  }\n}\n","import {BehaviorSubject, Observable} from \"rxjs\";\nimport {Board} from \"./board\";\nimport {concatMap, filter, share} from \"rxjs/operators\";\nimport {MazeGenerator} from \"../generators\";\nimport {Position} from \"../utils\";\n\n/*--------------\n * Interfaces\n *-------------- */\n\nexport interface BoardOptions {\n  width: number;\n  height: number;\n  generator: MazeGenerator,\n}\n\n/*-------------------\n * Reactive instance\n *------------------- */\n\nconst board$ = new BehaviorSubject<BoardOptions>(null)\n\n\n/*-------------------\n * Actions\n *------------------- */\n\n/**\n * Reset board with last board settings\n */\nexport function resetBoard() {\n  board$.next(board$.getValue());\n}\n\n/**\n * generate a new board with given board `options`\n */\nexport function newBoard(options: BoardOptions) {\n  board$.next(options);\n}\n\n/*-------------------\n * Helpers\n *------------------- */\n\n/**\n * Checks if the given position is last position of cell\n * useful to test game win state\n */\nexport function isLastCell({x, y}: Position): boolean {\n  const {width, height} = board$.getValue();\n  return x === width - 1 && y === height - 1;\n}\n\n/*-------------------\n * Functions\n *------------------- */\n\nexport function mountBoard(): Observable<Board> {\n  return board$\n    .pipe(\n      filter(ev => !!ev),\n      concatMap(async ({width, height, generator}) => {\n        let board = new Board(width, height);\n        return generator.generate(board);\n      }),\n      share(),\n    );\n}\n","import {h} from \"../utils\";\nimport {IRenderer} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {Observable} from \"rxjs\";\nimport {Player} from \"../player\";\n\nexport default class RectangularSvg implements IRenderer {\n  /*\n   * Some rendering options\n   * should some easier way to set them\n   */\n  public cellSize = 30;\n  public lineWidth = 2;\n  public playerPadding = 7;\n\n  constructor() {\n    // setting a css variable for wall animation\n    let root = document.documentElement;\n    root.style.setProperty('--cell-size', this.cellSize + 'px');\n  }\n\n  /**\n   * Renders game board to svg\n   *\n   * The idea is renderer will be initialized only once\n   * and then render function will be called for each new board,\n   * while renderer will take care of player changes without explicitly\n   * rerendering of board.\n   *\n   * @param board individual board snapshot\n   * @param player$ Observable of player position changes\n   */\n  render(board: Board, player$: Observable<Player>): HTMLElement {\n    const width = this.cellSize * (board.size.width + 2) + this.lineWidth;\n    const height = this.cellSize * (board.size.height + 2) + this.lineWidth;\n    const playerEl = this.renderPlayer();\n\n    // listen to player changes and update player on board\n    player$\n      .subscribe(({position}) => {\n        const [x, y] = [position.x, position.y]\n          .map((e) => (this.cellSize * e) + this.playerPadding + this.cellSize);\n\n        playerEl.setAttribute('x', x + '');\n        playerEl.setAttribute('y', y + '');\n      })\n\n    // render path definition string for each cell\n    // and join them to create single path string\n    // for whole board\n    let path = board.cells.map((value) => {\n      return this.renderCell(value, board.size);\n    }).join('');\n\n    return (\n      <svg stroke=\"currentColor\" fill=\"none\" width={width} height={height} viewBox={`0 0 ${width} ${height}`}>\n        {playerEl}\n        <path d={path} class=\"maze-wall\" stroke-width={this.lineWidth} stroke-linecap=\"round\"/>\n      </svg>\n    );\n  }\n\n  /**\n   * Renders player as svg rect\n   */\n  renderPlayer() {\n    const size = this.cellSize - (this.playerPadding * 2);\n    return <rect width={size} height={size} fill=\"currentColor\"\n                 class=\"text-blue-500\"\n                 stroke-width=\"0\" rx=\"3\" id=\"player\"\n                 x={1 + this.playerPadding + this.cellSize} y={1 + this.playerPadding + this.cellSize}/>;\n  }\n\n  /**\n   * Renders a single cell walls to svg path string\n   * @param cell cell to render\n   * @param size board size\n   */\n  renderCell(cell: Cell, size: { width: number, height: number }): string {\n    const pivotX = cell.position.x * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    const pivotY = cell.position.y * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    let path = '';\n\n    if (cell.hasWall(RectangularDirection.UP)) {\n      // Top wall\n      path += `M${pivotX},${pivotY}H${pivotX + this.cellSize}`;\n    }\n\n    if (cell.hasWall(RectangularDirection.LEFT)) {\n      // Left wall\n      path += `M${pivotX},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.x + 1 === size.width && cell.hasWall(RectangularDirection.RIGHT)) {\n      // Right Wall\n      path += `M${pivotX + this.cellSize},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.y + 1 === size.height) {\n      // Bottom Wall\n      path += `M${pivotX},${pivotY + this.cellSize}H${pivotX + this.cellSize}`;\n    }\n\n    return path;\n  }\n}\n","import {IRenderer} from \"./types\";\nimport RectangularSvg from './rectangularSvg';\n\nexport enum Renderers {\n  rectangularSvg\n}\n\nclass RendererManager {\n  private renderers = new Map<Renderers, IRenderer>();\n\n  async loadRenderer(name: Renderers) {\n    if (this.renderers.has(name)) {\n      return this.renderers.get(name);\n    }\n\n    // Just easiest work around for rollup dynamic imports\n    let module;\n    switch (name) {\n      case Renderers.rectangularSvg:\n        module = RectangularSvg;\n        break;\n    }\n\n    const renderer = new module();\n    this.renderers.set(name, renderer);\n    return renderer;\n  }\n}\n\nexport default new RendererManager();\n","import {animationFrameScheduler, BehaviorSubject, merge, Observable} from \"rxjs\";\nimport {Keyboard, Swipe} from \"../browser\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {Position} from \"../utils\";\nimport {filter, map, observeOn, withLatestFrom} from \"rxjs/operators\";\n\n/*------------------\n * Types\n *------------------*/\n\nexport interface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  board$: Observable<Board>;\n}\n\nexport interface Player {\n  state: 'active' | 'inactive' | 'hidden';\n  position: Position;\n}\n\nexport interface Control {\n  dir: RectangularDirection\n}\n\n/*------------------\n * Maps\n *------------------*/\n\nexport const keyMap = {\n  'ArrowRight': RectangularDirection.RIGHT,\n  'ArrowLeft': RectangularDirection.LEFT,\n  'ArrowUp': RectangularDirection.UP,\n  'ArrowDown': RectangularDirection.DOWN,\n}\n\n/*--------------------\n * Reactive instance\n *--------------------*/\n\nconst player$ = new BehaviorSubject<Player>({\n  state: 'active',\n  position: {x: 0, y: 0}\n});\n\n\n/*--------------------\n * Actions\n *--------------------*/\n\n/**\n * Set player Position\n */\nexport function setPlayerPosition(position: Position) {\n  const {state} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Set player Position\n */\nexport function setPlayerState(state: 'active' | 'inactive' | 'hidden') {\n  const {position} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Move player in given direction\n */\nexport function moveInDirection(dir: RectangularDirection, board: Board) {\n  let {position: {x, y}} = player$.getValue();\n\n  // continue to moving player in the direction until cell is a passage\n  do {\n    if (dir === 'right' && x < (board.size.width - 1)) {\n      x++;\n    } else if (dir === 'left' && x > 0) {\n      x--;\n    } else if (dir === 'up' && y > 0) {\n      y--;\n    } else if (dir === 'down' && y < (board.size.height - 1)) {\n      y++;\n    }\n\n    const visitable = board.getNeighbourCells({x, y}, true);\n    if (!visitable.has(dir) || visitable.size > 2) {\n      break;\n    }\n  } while (true);\n\n  setPlayerPosition({x, y});\n}\n\n/*--------------------\n * Functions\n *--------------------*/\n\n/**\n * Mount player to game logic\n *\n * returns a observable player\n */\nexport function mountPlayer(\n  {keyboard$, swipe$, board$}: MountOptions\n): Observable<Player> {\n\n  // reset player whenever new board is emitted\n  board$.subscribe(() => {\n    const {position: {x, y}} = player$.getValue();\n    if (x !== 0 || y !== 0) {\n      setPlayerPosition({x: 0, y: 0})\n    }\n  })\n\n  // combine touch and keyboard events\n  const control$: Observable<Control> = merge(\n    keyboard$,\n    swipe$,\n  ).pipe(\n    map((dir) => {\n      if ((dir as Keyboard).type) {\n        // @ts-ignore\n        return {dir: keyMap[dir.type]}\n      }\n      return dir as Swipe;\n    })\n  )\n\n  control$\n    .pipe(\n      withLatestFrom(board$),\n      // don't move player if there is a wall in control direction\n      // or player is not active\n      filter(([{dir}, board]) => {\n        const {position: {x, y}, state} = player$.getValue();\n        return state === 'active' && !board.hasWall({x, y}, dir);\n      })\n    )\n    .subscribe(([{dir}, board]) => {\n      moveInDirection(dir, board)\n    });\n\n  // use animationFrameScheduler to ensure smooth animations\n  return player$.pipe(\n    observeOn(animationFrameScheduler)\n  )\n}\n","import {watchKeyboard, watchSwipe} from \"./browser\";\nimport {Generators} from './generators';\nimport {newBoard, resetBoard} from \"./board\";\nimport {fromEvent} from \"rxjs\";\nimport {mountGame} from \"./game\";\n\n/*\n * References to some required document elements\n * Technically this should be done after DOM Content Loaded\n * But for some reason its working :)\n */\nconst boardEl = document.getElementById('board');\nconst boardWrapperEl = document.getElementById('boardWrapper');\nconst ResetEl = document.getElementById('reset');\n\n\n/* initialize all the observables */\nconst keyboard$ = watchKeyboard();\nconst swipe$ = watchSwipe(boardWrapperEl);\n\nmountGame({keyboard$, swipe$, boardEl});\n\n/*\n * Initialize board with initial options.\n * Every other price of the board depends on\n * some non-null value of board option\n */\nnewBoard({\n  height: 15,\n  width: 15,\n  generator: Generators.HuntAndKill,\n});\n\n\n/* Bind events with buttons */\nfromEvent(ResetEl, 'click')\n  .subscribe(resetBoard);\n","import {Size} from \"../utils\";\nimport {MazeGenerator} from \"../generators\";\nimport renderersManager, {Renderers} from \"../renderers\";\nimport {Observable} from \"rxjs\";\nimport {Keyboard} from \"../browser/keyboard\";\nimport {Swipe} from \"../browser/touch\";\nimport {isLastCell, mountBoard, resetBoard} from \"../board\";\nimport {mountPlayer, setPlayerPosition, setPlayerState} from \"../player\";\nimport {removeElementChildren} from \"../browser/element\";\nimport {filter} from \"rxjs/operators\";\nimport {default as canvasConfetti} from \"canvas-confetti\";\n\nexport interface GameOptions {\n  size: Size;\n  generator: MazeGenerator;\n  renderer: Renderers;\n  interactive: boolean;\n  showPlayer: boolean;\n}\n\ninterface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  boardEl: HTMLElement;\n}\n\n/**\n * Handle keyboard shortcuts\n */\nfunction registerShortcuts(keyboard$: Observable<Keyboard>) {\n  keyboard$.subscribe(({type}) => {\n    /* 'r' to reset game */\n    if (type.toLowerCase() === 'r') {\n      resetBoard();\n    }\n  })\n}\n\nexport function mountGame({keyboard$, swipe$, boardEl}: MountOptions) {\n  registerShortcuts(keyboard$);\n\n  const board$ = mountBoard();\n  const player$ = mountPlayer({keyboard$, board$, swipe$});\n\n  /* render board whenever new board is emitted */\n  board$\n    .subscribe((board) => {\n      setPlayerState('active');\n      renderersManager.loadRenderer(Renderers.rectangularSvg).then((render) => {\n        removeElementChildren(boardEl);\n        boardEl.appendChild(\n          render.render(board, player$)\n        );\n      })\n    });\n\n  player$\n    .pipe(\n      filter(({position, state}) => isLastCell(position) && state === 'active'),\n    )\n    .subscribe(async ({position: {x, y}}) => {\n      const start = new Date().getTime();\n      setPlayerState('inactive');\n\n      let confetti: typeof canvasConfetti;\n      try {\n        const canvasConfetti = await import('canvas-confetti');\n        confetti = canvasConfetti.default;\n      } catch (e) {\n        console.error(e);\n      }\n\n      const timeDiff = new Date().getTime() - start;\n      if (timeDiff >= 250) {\n        setPlayerPosition({x: x + 1, y});\n\n        if (confetti)\n          confetti({origin: {y: 0.8}, particleCount: 100}).then();\n      } else {\n        setTimeout(() => {\n          setPlayerPosition({x: x + 1, y});\n          if (confetti)\n            confetti({origin: {y: 0.8}, particleCount: 100}).then();\n        }, 250 - timeDiff);\n      }\n    });\n}\n","/**\n * Retrieve the currently active element\n *\n * @returns Element or nothing\n */\nexport function getActiveElement(): HTMLElement | undefined {\n  return document.activeElement instanceof HTMLElement\n    ? document.activeElement\n    : undefined\n}\n\n\n/**\n * Remove all the children of given element\n */\nexport function removeElementChildren(element: HTMLElement): void {\n  while (element.lastElementChild) {\n    element.removeChild(element.lastElementChild);\n  }\n}\n","import {fromEvent, Observable} from \"rxjs\";\nimport {filter, map, share} from \"rxjs/operators\";\nimport {getActiveElement} from \"../element\";\n\n/**\n * Keyboard\n */\nexport interface Keyboard {\n  type: string                         /* Key type */\n  claim(): void                        /* Key claim */\n}\n\n/**\n * Check whether an element may receive keyboard input\n *\n * @param el - Element\n *\n * @returns Test result\n */\nfunction isSusceptibleToKeyboard(el: HTMLElement): boolean {\n  switch (el.tagName) {\n    /* Form elements */\n    case \"INPUT\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      return true\n\n    /* Everything else */\n    default:\n      return el.isContentEditable\n  }\n}\n\n/**\n * Watch keyboard\n *\n * @returns Keyboard observable\n */\nexport function watchKeyboard(): Observable<Keyboard> {\n  return fromEvent<KeyboardEvent>(window, \"keydown\")\n    .pipe(\n      filter(ev => !(ev.metaKey || ev.ctrlKey)),\n      map(ev => ({\n        type: ev.key,\n        claim() {\n          ev.preventDefault()\n          ev.stopPropagation()\n        }\n      } as Keyboard)),\n      filter(() => {\n        const active = getActiveElement()\n        if (typeof active !== \"undefined\")\n          return !isSusceptibleToKeyboard(active)\n\n        return true\n      }),\n      share(),\n    )\n}\n","import {from, fromEvent, merge, NEVER, Observable} from \"rxjs\";\nimport {map, share, switchMap} from \"rxjs/operators\";\nimport {RectangularDirection} from \"../../board\";\n\nexport interface Swipe {\n  dir: RectangularDirection;\n}\n\n/**\n * Watch swipe events on the given element using hammerjs\n */\nexport function watchSwipe(element = document.documentElement): Observable<Swipe> {\n  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n\n  if (!isTouchDevice) {\n    return NEVER;\n  }\n\n  return from(import('hammerjs'))\n    .pipe(\n      switchMap((hammer) => {\n        const mc = new hammer.Manager(element);\n        mc.add(new hammer.Swipe());\n\n        return merge(\n          fromEvent(mc, 'swipeleft'),\n          fromEvent(mc, 'swiperight'),\n          fromEvent(mc, 'swipeup'),\n          fromEvent(mc, 'swipedown'),\n        )\n      }),\n      map(({type}) => {\n        return {dir: type.slice(5)};\n      }),\n      share(),\n    )\n}\n"],"names":["positionToIndex","position","width","y","x","stringifyPosition","CellSet","Map","[object Object]","cells","super","this","addAll","cell","set","add","has","delete","remove","Array","from","values","Math","round","random","length","appendChild","el","child","innerHTML","toString","Node","isArray","node","h","tag","attributes","children","svgTags","includes","document","createElementNS","createElement","attr","Object","keys","setAttribute","shuffle","array","temporaryValue","randomIndex","currentIndex","floor","PathSetGenerator","pathSets","hasCell","cell1","cell2","set1","getSetFromCell","set2","i","indexOf","splice","push","getUnvisitedCell","board","visitedCells","getRandomInt","min","max","randomWalkUntil","until","path","neighbourCells","getNeighbourCells","filter","list","Generators","RecursiveBackTrack","clone","removeWall","randomCell","getRandomCell","visitCell","removeInterWall","AldousBroder","currentCell","movingTowards","size","height","cellNeighbours","unvisitedCells","dx","sign","dy","getCell","BinaryTree","topBias","rightBias","dir","getRelativeDirection","Eller","visitRow","visitNextRow","index","mergeAll","isFromSameSet","joinCellSets","setCells","entries","key","map","n","nextCell","Kruskal","neighbours","randomNeighbour","HuntAndKill","neighbourCell","some","PrimsRandomization","getRandom","randomCellNeighbours","randomCellNeighbour","removeAll","Wilson","Sidewinder","joinedCells","OpposingRectangularDirection","left","right","up","down","Cell","walls","setAllWalls","setWall","get","hasWall","Board","initCells","visitableOnly","visitableNeighbours","hasInterWall","direction","relativeWallDirection","opposingWallDirection","relativeWall","opposingWall","board$","BehaviorSubject","resetBoard","next","getValue","isLastCell","mountBoard","pipe","ev","concatMap","async","generator","generate","share","RectangularSvg","documentElement","style","setProperty","cellSize","player$","lineWidth","playerEl","renderPlayer","subscribe","e","playerPadding","value","renderCell","join","stroke","fill","viewBox","d","class","rx","id","pivotX","pivotY","Renderers","name","renderers","module","rectangularSvg","renderer","keyMap","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","state","setPlayerPosition","setPlayerState","mountPlayer","keyboard$","swipe$","merge","type","withLatestFrom","visitable","moveInDirection","observeOn","animationFrameScheduler","boardEl","getElementById","boardWrapperEl","ResetEl","options","toLowerCase","registerShortcuts","renderersManager","loadRenderer","then","render","element","lastElementChild","removeChild","removeElementChildren","start","Date","getTime","confetti","canvasConfetti","import","default","console","error","timeDiff","origin","particleCount","setTimeout","mountGame","fromEvent","window","metaKey","ctrlKey","preventDefault","stopPropagation","active","activeElement","HTMLElement","undefined","tagName","isContentEditable","isSusceptibleToKeyboard","navigator","maxTouchPoints","msMaxTouchPoints","switchMap","hammer","mc","Manager","Swipe","slice","NEVER","watchSwipe"],"mappings":"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"}