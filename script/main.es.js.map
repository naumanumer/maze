{"version":3,"file":"main.es.js","sources":["../../src/utils/point.ts","../../src/utils/cellSet.ts","../../src/utils/h/svgTags.ts","../../src/utils/h/index.ts","../../src/utils/array.ts","../../src/generators/_pathSetGenerator.ts","../../src/utils/markovDecision.ts","../../src/generators/utils.ts","../../src/generators/index.ts","../../src/generators/recursiveBackTrack.ts","../../src/generators/aldousBroder.ts","../../src/generators/binaryTree.ts","../../src/generators/eller.ts","../../src/generators/kruskal.ts","../../src/generators/huntAndKill.ts","../../src/generators/primsRandomization.ts","../../src/generators/wilson.ts","../../src/generators/sidewinder.ts","../../src/board/cell.ts","../../src/board/board.ts","../../src/board/_.ts","../../src/renderers/rectangularSvg.tsx","../../src/renderers/index.ts","../../src/player/index.ts","../../src/main.ts","../../src/game/index.ts","../../src/browser/element/index.ts","../../src/browser/keyboard/index.ts","../../src/browser/touch/index.ts"],"sourcesContent":["export interface Position {\n  readonly x: number;\n  readonly y: number;\n}\n\n/**\n * Convert a position (2d) to linear index\n */\nexport function positionToIndex(position: Position, width: number): number {\n  return position.y * width + position.x;\n}\n\nexport function stringifyPosition(position: Position) {\n  return `${position.x}-${position.y}`;\n}\n","import {Cell} from \"../board\";\nimport {stringifyPosition} from \"./point\";\n\nexport class CellSet extends Map<string, Cell> {\n  constructor(cells?: Cell[]) {\n    super();\n\n    if (cells) this.addAll(cells);\n  }\n\n  add(cell: Cell) {\n    return this.set(stringifyPosition(cell.position), cell);\n  }\n\n  addAll(cells: Cell[]) {\n    for (let cell of cells)\n      this.add(cell);\n  }\n\n  hasCell(cell: Cell) {\n    return this.has(stringifyPosition(cell.position));\n  }\n\n  remove(cell: Cell) {\n    return this.delete(stringifyPosition(cell.position));\n  }\n\n  removeAll(cells: Cell[]) {\n    for (let cell of cells)\n      this.remove(cell);\n  }\n\n  getRandom(): Cell {\n    const cells = Array.from(this.values());\n    return cells[Math.round(Math.random() * (cells.length -1))];\n  }\n}\n","export default [\"circle\", \"defs\", \"ellipse\", \"filter\", \"g\", \"line\", \"path\", \"rect\", \"svg\"]\n","/*\n * Adopted from https://github.com/squidfunk/mkdocs-material/blob/master/src/assets/javascripts/utilities/h/index.ts\n * with additional support for svg elements\n */\n\nimport {JSX as JSXInternal} from \"preact\"\nimport svgTags from \"./svgTags\";\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes =\n  & JSXInternal.HTMLAttributes\n  & JSXInternal.SVGAttributes\n  & Record<string, any>\n\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nfunction appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory\n *\n * @param tag - HTML tag\n * @param attributes - HTML attributes\n * @param children - Child elements\n *\n * @returns Element\n */\nexport function h(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(attr, attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(attr, \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n\n\n/* This override is necessary for types to work */\nexport declare namespace h {\n  namespace JSX {\n    type Element = HTMLElement\n    type IntrinsicElements = JSXInternal.IntrinsicElements\n  }\n}\n","export function shuffle(array: any[]) {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import {Cell} from \"../board\";\nimport {CellSet} from \"../utils/cellSet\";\nimport set = Reflect.set;\n\nexport type PathSet = Record<string, Cell>;\n\nexport abstract class PathSetGenerator {\n  protected getSetFromCell(cell: Cell, pathSets: CellSet[]): CellSet | undefined {\n    for (let set of pathSets) {\n      if (set.hasCell(cell)) {\n        return set;\n      }\n    }\n  }\n\n  protected joinCellSets(cell1: Cell, cell2: Cell, pathSets: CellSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    if (!set1 && !set2) {\n      pathSets.push(new CellSet([cell1, cell2]));\n    } else if (set1 == null) {\n      set2.add(cell1);\n    } else if (set2 == null) {\n      set1.add(cell2);\n    } else {\n      set1.addAll(Array.from(set2.values()));\n      const i = pathSets.indexOf(set2);\n      pathSets.splice(i, 1);\n    }\n  }\n\n  protected isFromSameSet(cell1: Cell, cell2: Cell, pathSets: CellSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    return !!set1 && !!set2 && set1 == set2;\n  }\n}\n","export interface Environment<T> {\n  /** Number of allowed actions at given state */\n  allowedActions(state: number): T[]\n\n  nextState(state: number, action: T): number;\n\n  reward(state: number, action: T, nextState: number): number;\n\n  /** Number of total states in the environment */\n  stateSize: number;\n\n  /** Number of max actions available at any given state */\n  maxActions: number;\n}\n\nfunction sampleWeighted(probabilities: number[]): number {\n  const r = Math.random();\n  let c = 0.0;\n  for (let i = 0; i < probabilities.length; i++) {\n    c += probabilities[i];\n    if (c >= r) {\n      return i;\n    }\n  }\n}\n\nexport class MarkovDecision<T extends number> {\n  private ValueTable: Float32Array;\n  private PolicyTable: Float32Array;\n\n  /**\n   * @param env the environment\n   * @param gamma the discount factor\n   */\n  constructor(private env: Environment<T>, private gamma = 0.75) {\n    this.ValueTable = new Float32Array(env.stateSize);\n\n    // stores probability of each action on each state\n    this.PolicyTable = new Float32Array(env.stateSize * env.maxActions);\n\n    for (let s = 0; s < env.stateSize; s++) {\n      const possibilities = this.env.allowedActions(s);\n      for (let possibility of possibilities) {\n        this.PolicyTable[possibility * env.stateSize + s] = 1.0 / possibilities.length;\n      }\n    }\n  }\n\n  act(state: number): T {\n    const allowedActions = this.env.allowedActions(state);\n    let ps = [];\n    for (let action of allowedActions) {\n      const prob = this.PolicyTable[action * this.env.stateSize + state];\n      ps.push(prob);\n    }\n    const i = sampleWeighted(ps);\n    return allowedActions[i];\n  }\n\n  learn() {\n    this.evaluatePolicy();\n    this.updatePolicy();\n  }\n\n  evaluatePolicy() {\n    const newValueTable = new Float32Array(this.env.stateSize);\n    for (let state = 0; state < this.env.stateSize; state++) {\n      let v = 0.0;\n      const possibilities = this.env.allowedActions(state);\n\n      for (let action of possibilities) {\n        const prob = this.PolicyTable[action * this.env.stateSize + state] // probability of taking action under policy\n        if (prob === 0) continue;// no contribution, skip for speed\n        let nextState = this.env.nextState(state, action);\n        let reward = this.env.reward(state, action, nextState); // reward for s->a->ns transition\n        v += prob * (reward + this.gamma * this.ValueTable[nextState]);\n      }\n      newValueTable[state] = v;\n    }\n    this.ValueTable = newValueTable;\n  }\n\n  updatePolicy() {\n    for (let state = 0; state < this.env.stateSize; state++) {\n      const possibilities = this.env.allowedActions(state);\n      let vMax, nMax, vs = [];\n      for (let action of possibilities) {\n        const nextState = this.env.nextState(state, action);\n        const reward = this.env.reward(state, action, nextState);\n        const v = reward + this.gamma * this.ValueTable[nextState];\n        vs.push(v);\n        if (action === possibilities[0] || v > vMax) {\n          vMax = v;\n          nMax = 1;\n        } else if (v === vMax) {\n          nMax += 1;\n        }\n      }\n\n      // update policy smoothly across all actions\n      for (let i = 0; i < possibilities.length; i++) {\n        const action = possibilities[i];\n        this.PolicyTable[action * this.env.stateSize + state] = (vs[i] === vMax) ? 1.0 / nMax : 0.0;\n      }\n    }\n  }\n}\n","import {Board, Cell, RectangularDirection} from \"../board\";\nimport {stringifyPosition} from \"../utils\";\nimport {CellSet} from \"../utils/cellSet\";\nimport {MarkovDecision} from \"../utils/markovDecision\";\n\n/** return first unvisited cell from board */\nexport function getUnvisitedCell(board: Board, visitedCells: CellSet) {\n  for (let cell of board.cells) {\n    if (!visitedCells.has(stringifyPosition(cell.position))) {\n      return cell;\n    }\n  }\n}\n\n/** return a random element from array */\nexport function getRandomFrom<T>(list: T[]): T {\n  return list[Math.round(Math.random() * (list.length - 1))];\n}\n\n/** return a random int between min (inclusive) and max (exclusive) */\nexport function getRandomInt(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\n/** convert xy to state index */\nfunction stateToXY(state: number, board: Board): [number, number] {\n  return [state % board.size.height, Math.floor(state / board.size.height)];\n}\n\n/** convert state index to xy */\nfunction xyToState([x, y]: [number, number], board: Board) {\n  return y * board.size.width + x;\n}\n\n// wilson, hunt&kill, aldousBroder, backtrack\n/**\n * Do a random walk in the board until some condition is fulfilled\n * Using markov decision process to optimize random walks\n */\nexport function randomWalkUntil(\n  cell: Cell,\n  board: Board,\n  until: (cell: Cell, path: Cell[]) => boolean,\n  visitedCells: CellSet = null,\n  walkInVisited = false,\n  path: Cell[] = [],\n): Cell[] {\n  const model = new MarkovDecision<RectangularDirection>({\n    stateSize: board.size.height * board.size.width,\n    maxActions: 4,\n    allowedActions(state: number) {\n     const actions = [];\n     const [x, y] = stateToXY(state, board);\n     if (x > 0) actions.push(RectangularDirection.LEFT);\n     if (y > 0) actions.push(RectangularDirection.UP);\n     if (x < board.size.width - 1) actions.push(RectangularDirection.RIGHT);\n     if (y < board.size.height - 1) actions.push(RectangularDirection.DOWN);\n\n     return actions;\n    },\n    nextState(state: number, action: number): number {\n      let [x, y] = stateToXY(state, board);\n      if (action === RectangularDirection.UP) y--;\n      if (action === RectangularDirection.DOWN) y++;\n      if (action === RectangularDirection.LEFT) x--;\n      if (action === RectangularDirection.RIGHT) x++;\n      return xyToState([x, y], board);\n    },\n    reward(state: number, action: number, nextState: number): number {\n      const [x, y] = stateToXY(nextState, board);\n      const cell = board.getCell({x, y});\n      if (visitedCells && (walkInVisited ? !visitedCells.hasCell(cell) : visitedCells.hasCell(cell))) {\n        return -1;\n      }\n      if (path.includes(cell)) {\n        return -1;\n      }\n      return 1;\n    },\n  })\n\n  while (until(cell, path)) {\n    path.push(cell);\n\n    const {x, y} = cell.position;\n    model.learn();\n    let direction = model.act(xyToState([x, y], board));\n    cell = board.getNeighbourCell(cell.position, direction);\n  }\n\n  if (!path.includes(cell)) {\n    path.push(cell);\n  }\n  return path;\n}\n","import RecursiveBacktrack from \"./recursiveBackTrack\";\nimport AldousBroder from \"./aldousBroder\";\nimport BinaryTree from \"./binaryTree\";\nimport Eller from \"./eller\";\nimport Kruskal from \"./kruskal\";\nimport HuntAndKill from \"./huntAndKill\";\nimport PrimsRandomization from \"./primsRandomization\";\nimport {Wilson} from \"./wilson\";\nimport {Sidewinder} from \"./sidewinder\";\n\nexport * from './types';\n\nexport const Generators = {\n  RecursiveBackTrack: new RecursiveBacktrack(),\n  AldousBroder: new AldousBroder(),\n  BinaryTree: new BinaryTree(),\n  Eller: new Eller(),\n  Kruskal: new Kruskal(),\n  HuntAndKill: new HuntAndKill(),\n  PrimsRandomization: new PrimsRandomization(),\n  Wilson: new Wilson(),\n  Sidewinder: new Sidewinder(),\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * Depth first recursive backtrack maze generation algorithm\n * https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n *\n * Generates long dead ends making the solution little difficult\n */\nexport default class RecursiveBacktrack implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    const randomCell = board.getRandomCell();\n\n    this.visitCell(randomCell, visitedCells, board);\n    return board;\n  }\n\n  visitCell(cell: Cell, visitedCells: CellSet, board: Board) {\n    visitedCells.add(cell);\n    const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n\n    while (neighbourCells.length !== 0) {\n      // select a random neighbour\n      const i = Math.round(Math.random() * (neighbourCells.length - 1));\n      const randomCell = neighbourCells[i];\n\n      // if random neighbour is not already visited remove wall between\n      // random neighbour and current cell and recursively visit that neighbour\n      if (!visitedCells.hasCell(randomCell)) {\n        board.removeInterWall(cell.position, randomCell.position);\n        this.visitCell(randomCell, visitedCells, board);\n      }\n\n      // after visit remove random neighbour from neighbourCells\n      neighbourCells.splice(i, 1);\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm\n */\nexport default class AldousBroder implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    let currentCell = board.getRandomCell();\n    const visitedCells = new CellSet();\n    visitedCells.add(currentCell);\n\n    let movingTowards;\n\n    while (visitedCells.size < board.size.height * board.size.width) {\n      const cellNeighbours = Array.from(board.getNeighbourCells(currentCell.position).values());\n\n      const unvisitedNeighbours = cellNeighbours.filter((cell) => {\n        return !visitedCells.hasCell(cell);\n      })\n\n      // If there are some unvisited neighbours choose any random neighbour and visit it\n      if (unvisitedNeighbours.length > 0) {\n        let randomCell = cellNeighbours[Math.round((cellNeighbours.length - 1) * Math.random())];\n        if (!visitedCells.hasCell(randomCell)) {\n          board.removeInterWall(randomCell.position, currentCell.position)\n          visitedCells.add(randomCell);\n          movingTowards = null;\n        }\n\n        currentCell = randomCell;\n      } else {\n        // else just find random unvisited cell and move towards that cell\n        // until you hit some cell which has some unvisited neighbours\n        // NOTE: its not from actual algorithm but doing make this algorithm to always end in finite time\n\n        if (!movingTowards) {\n          const unvisitedCells = board.cells.filter((cell) => {\n            return !visitedCells.hasCell(cell);\n          });\n\n          movingTowards = unvisitedCells[Math.round((unvisitedCells.length - 1) * Math.random())]\n        }\n\n        let dx = Math.sign(movingTowards.position.x - currentCell.position.x);\n        let dy = dx === 0 ? Math.sign(movingTowards.position.y - currentCell.position.y) : 0;\n        currentCell = board.getCell({x: currentCell.position.x + dx, y: currentCell.position.y + dy});\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\n\n/**\n * http://weblog.jamisbuck.org/2011/2/1/maze-generation-binary-tree-algorithm\n */\nexport default class BinaryTree implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const topBias = Math.random() > 0.5;\n    const rightBias = Math.random() > 0.5;\n\n    for (let currentCell of board.cells) {\n      let neighbourCells = Array.from(board.getNeighbourCells(currentCell.position).values());\n      neighbourCells = neighbourCells.filter((cell) => {\n        const dir = board.getRelativeDirection(currentCell.position, cell.position);\n\n        return (rightBias && dir == RectangularDirection.LEFT) ||\n          (!rightBias && dir == RectangularDirection.RIGHT) ||\n          (topBias && dir == RectangularDirection.DOWN) ||\n          (!topBias && dir == RectangularDirection.UP);\n      });\n\n      if (neighbourCells.length > 0) {\n        const randomCell = neighbourCells[Math.round((neighbourCells.length - 1) * Math.random())];\n        board.removeInterWall(randomCell.position, currentCell.position)\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {shuffle} from \"../utils\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport default class Eller extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: CellSet[] = [];\n\n    for (let x = 0; x < board.size.width; x++) {\n      const cell = board.getCell({x, y: 0});\n      pathSets.push(new CellSet([cell]));\n    }\n\n    for (let y = 0; y < board.size.height - 1; y++) {\n      this.visitRow(y, false, board, pathSets);\n      this.visitNextRow(y, board, pathSets);\n    }\n\n    this.visitRow(board.size.height - 1, true, board, pathSets);\n    return board;\n  }\n\n  private visitRow(index: number, mergeAll: boolean, board: Board, pathSets: CellSet[]) {\n    for (let x = 1; x < board.size.width; x++) {\n      const cell1 = board.getCell({y: index, x: x - 1});\n      const cell2 = board.getCell({y: index, x});\n\n      if (this.isFromSameSet(cell1, cell2, pathSets)) {\n        continue;\n      }\n\n      if (Math.random() > 0.5 || mergeAll) {\n        board.removeInterWall(cell1.position, cell2.position);\n        this.joinCellSets(cell1, cell2, pathSets);\n      } else if (this.getSetFromCell(cell1, pathSets) == null) {\n        pathSets.push(new CellSet([cell1]));\n      } else if (this.getSetFromCell(cell2, pathSets) == null) {\n        pathSets.push(new CellSet([cell2]));\n      }\n    }\n  }\n\n  private visitNextRow(index: number, board: Board, pathSets: CellSet[]) {\n    for (let set of pathSets) {\n      let setCells = Array.from(set.entries())\n        .filter(([key, cell]) => {\n          return cell.position.y === index;\n        })\n        .map(([key, cell]) => cell);\n\n      setCells = shuffle(setCells);\n      let n = 1 + Math.round(Math.random() * (setCells.length - 1));\n      for (let i = 0; i < n; i++) {\n        const cell = setCells[i];\n        const nextCell = board.getCell({x: cell.position.x, y: cell.position.y + 1});\n\n        board.removeInterWall(cell.position, nextCell.position);\n        set.add(nextCell);\n      }\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/3/maze-generation-kruskal-s-algorithm\n */\nexport default class Kruskal extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: CellSet[] = [];\n\n    for (let cell of board.cells) {\n      pathSets.push(new CellSet([cell]));\n    }\n\n    while (pathSets.length > 1) {\n      const randomCell = board.getRandomCell();\n      const neighbours = Array.from(board.getNeighbourCells(randomCell.position).values());\n      const randomNeighbour = neighbours[Math.round((neighbours.length - 1) * Math.random())]\n\n      if (this.isFromSameSet(randomCell, randomNeighbour, pathSets)) continue;\n\n      board.removeInterWall(randomCell.position, randomNeighbour.position);\n      this.joinCellSets(randomCell, randomNeighbour, pathSets);\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {PathSetGenerator} from \"./_pathSetGenerator\";\nimport {randomWalkUntil} from \"./utils\";\nimport {CellSet} from \"../utils/cellSet\";\nimport {stringifyPosition} from \"../utils\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/24/maze-generation-hunt-and-kill-algorithm\n */\nexport default class HuntAndKill extends PathSetGenerator implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and mark as visited to start from that cell\n    const visitedCells = new CellSet();\n    let cell = board.getRandomCell();\n    // visitedCells.add(cell);\n\n    while (cell) {\n      // start a random walk from this cell until there is a dead end\n      let path = randomWalkUntil(cell, board, (cell, path) => {\n        if (visitedCells.hasCell(cell)) return false;\n        visitedCells.add(cell);\n        let neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n        return neighbourCells.some((cell) => {\n          return !visitedCells.hasCell(cell);\n        });\n      }, visitedCells);\n\n      // remove wall between cells of path\n      for (let i = 1; i < path.length; i++) {\n        board.removeInterWall(path[i - 1].position, path[i].position);\n      }\n      visitedCells.addAll(path);\n\n      cell = this.hunt(board, visitedCells);\n    }\n    return board;\n  }\n\n  private hunt(board: Board, visitedCells: CellSet) {\n    for (let cell of board.cells) {\n      if (visitedCells.hasCell(cell)) continue;\n\n      const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n      for (let neighbourCell of neighbourCells) {\n        if (visitedCells.hasCell(neighbourCell)) {\n          board.removeInterWall(cell.position, neighbourCell.position);\n          return cell;\n        }\n      }\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {MazeGenerator} from \"./types\";\nimport {CellSet} from \"../utils/cellSet\";\n\n/**\n * Prim's Randomization Algorithm\n * http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm\n *\n * Generates relatively easy to solve mazes with short dead ends\n */\nexport default class PrimsRandomization implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new CellSet();\n    let randomCell = board.getRandomCell();\n    const neighbourCells = new CellSet(Array.from(board.getNeighbourCells(randomCell.position).values()));\n\n    visitedCells.add(randomCell);\n\n    while (neighbourCells.size > 0) {\n      randomCell = neighbourCells.getRandom();\n      const randomCellNeighbours = new CellSet(Array.from(board.getNeighbourCells(randomCell.position).values()));\n\n      for (let randomCellNeighbour of randomCellNeighbours.values()) {\n        if (visitedCells.hasCell(randomCellNeighbour)) {\n          board.removeInterWall(randomCellNeighbour.position, randomCell.position);\n\n          neighbourCells.remove(randomCell);\n          visitedCells.add(randomCell);\n          neighbourCells.addAll(Array.from(randomCellNeighbours.values()));\n          neighbourCells.removeAll(Array.from(visitedCells.values()));\n          break;\n        }\n      }\n    }\n\n    return board;\n  }\n}\n","import {MazeGenerator} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {CellSet} from \"../utils/cellSet\";\nimport {getRandomFrom, getUnvisitedCell, randomWalkUntil} from \"./utils\";\n\n/**\n * Wilson's Maze Generation Algorithm\n * https://weblog.jamisbuck.org/2011/1/20/maze-generation-wilson-s-algorithm\n *\n * It unlike many other algorithms generate generate mazes of unbiased complexity\n */\nexport class Wilson implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // mark a random cell a visited\n    const visitedCells = new CellSet();\n    visitedCells.add(board.getRandomCell());\n\n    // loop until not all the cells are visited\n    while (visitedCells.size < board.size.height * board.size.width) {\n      // get a visited cell -- just a fun fact its not random its first unvisited cell ;)\n      let randomCell = getUnvisitedCell(board, visitedCells);\n\n      // make random walk until not reached some visited cell\n      let path = randomWalkUntil(randomCell, board, (cell, path) => {\n        if (path.includes(cell)) {\n          const i = path.indexOf(cell);\n          path.splice(i, path.length);\n        }\n\n        return !visitedCells.hasCell(cell);\n      });\n\n      // remove wall between cells of path\n      for (let i = 1; i < path.length; i++) {\n        board.removeInterWall(path[i - 1].position, path[i].position);\n      }\n\n      // mark all the path cells as visited\n      visitedCells.addAll(path);\n    }\n\n    return board;\n  }\n}\n","import {MazeGenerator} from \"./types\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {getRandomInt} from \"./utils\";\n\n/**\n * https://weblog.jamisbuck.org/2011/2/3/maze-generation-sidewinder-algorithm#\n */\nexport class Sidewinder implements MazeGenerator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    for (let x = 1; x < board.size.width; x++) {\n      board.removeInterWall({y: 0, x: x}, {y: 0, x: x-1})\n    }\n\n    for (let y = 1; y < board.size.height; y++) {\n      this.visitRow(y, board);\n    }\n\n    return board;\n  }\n\n  private visitRow(y: number, board: Board) {\n    let joinedCells = 0;\n    for (let x = 1; x < board.size.width; x++) {\n      if (Math.random() > .5) {\n        board.removeInterWall({y, x: x - 1}, {y, x})\n        joinedCells++;\n      } else {\n        const h = getRandomInt(x - 1 - joinedCells, x);\n        board.removeInterWall({y, x: h}, {y: y - 1, x: h})\n        joinedCells = 0;\n      }\n    }\n\n    const h = getRandomInt(board.size.width - joinedCells - 1, board.size.width);\n    board.removeInterWall({y, x: h}, {y: y - 1, x: h})\n  }\n}\n","import {Position} from \"../utils\";\n\nexport const enum RectangularDirection {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n}\n\nexport const OpposingRectangularDirection = {\n  [RectangularDirection.LEFT]: RectangularDirection.RIGHT,\n  [RectangularDirection.RIGHT]: RectangularDirection.LEFT,\n  [RectangularDirection.UP]: RectangularDirection.DOWN,\n  [RectangularDirection.DOWN]: RectangularDirection.UP,\n};\n\nexport class Cell {\n  public readonly walls: Map<RectangularDirection, boolean>;\n\n  constructor(public readonly position: Position) {\n    this.walls = new Map<RectangularDirection, boolean>();\n    this.setAllWalls();\n  }\n\n  setAllWalls() {\n    this.setWall(RectangularDirection.UP);\n    this.setWall(RectangularDirection.RIGHT);\n    this.setWall(RectangularDirection.DOWN);\n    this.setWall(RectangularDirection.LEFT);\n  }\n\n  removeAllWalls() {\n    this.removeWall(RectangularDirection.UP);\n    this.removeWall(RectangularDirection.RIGHT);\n    this.removeWall(RectangularDirection.DOWN);\n    this.removeWall(RectangularDirection.LEFT);\n  }\n\n  setWall(dir: RectangularDirection) {\n    this.walls.set(dir, true);\n  }\n\n  removeWall(dir: RectangularDirection) {\n    this.walls.set(dir, false);\n  }\n\n  hasWall(dir: RectangularDirection): boolean {\n    return this.walls.get(dir);\n  }\n\n  clone() {\n    const cell = new Cell(this.position);\n    for (const [dir, hasWall] of this.walls.entries()) {\n      cell.walls.set(dir, hasWall);\n    }\n    return cell;\n  }\n}\n","import {Cell, OpposingRectangularDirection, RectangularDirection} from './cell';\nimport {Position, positionToIndex, Size} from \"../utils\";\n\nexport class Board {\n  public readonly cells: Array<Cell>;\n  public readonly size: Size;\n\n  constructor(width: number, height: number) {\n    this.size = {height, width};\n    this.cells = [];\n    this.initCells();\n  }\n\n  private initCells() {\n    for (let y = 0; y < this.size.height; y++) {\n      for (let x = 0; x < this.size.width; x++) {\n        this.cells.push(new Cell({x, y}));\n      }\n    }\n  }\n\n  getRandomCell(): Cell {\n    return this.cells[Math.round(Math.random() * (this.cells.length - 1))];\n  }\n\n  getCell(position: Position): Cell {\n    return this.cells[positionToIndex(position, this.size.width)];\n  }\n\n  getNeighbourCells(position: Position, visitableOnly: boolean = false): Map<RectangularDirection, Cell> {\n    let neighbours = new Map<RectangularDirection, Cell>(),\n      index = positionToIndex(position, this.size.width);\n\n    if (index >= this.size.width) {\n      const cell = this.cells[index - this.size.width];\n      neighbours.set(RectangularDirection.UP, cell);\n    }\n\n    if ((index + 1) % this.size.width != 0) {\n      const cell = this.cells[index + 1];\n      neighbours.set(RectangularDirection.RIGHT, cell);\n    }\n\n    if (index < this.cells.length - this.size.width) {\n      const cell = this.cells[index + this.size.width];\n      neighbours.set(RectangularDirection.DOWN, cell);\n    }\n\n    if (index % this.size.width != 0) {\n      const cell = this.cells[index - 1];\n      neighbours.set(RectangularDirection.LEFT, cell);\n    }\n\n    if (visitableOnly) {\n      const visitableNeighbours = Array.from(neighbours.entries())\n        .filter(([dir, cell]) => {\n          return !this.hasInterWall(cell.position, position);\n        });\n\n      neighbours = new Map(visitableNeighbours);\n    }\n\n    return neighbours;\n  }\n\n  getNeighbourCell(position: Position, direction: RectangularDirection): Cell {\n    const cells = this.getNeighbourCells(position);\n    return cells.get(direction);\n  }\n\n  getRelativeDirection(cell1: Position, cell2: Position): RectangularDirection {\n    if (cell1.y === cell2.y + 1) {\n      return RectangularDirection.UP;\n    }\n    if (cell1.x === cell2.x - 1) {\n      return RectangularDirection.RIGHT;\n    }\n    if (cell1.x === cell2.x + 1) {\n      return RectangularDirection.LEFT;\n    }\n    if (cell1.y === cell2.y - 1) {\n      return RectangularDirection.DOWN;\n    }\n    throw `'${cell1}' and '${cell2}' are not neighbours`;\n  }\n\n  removeInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).removeWall(relativeWallDirection);\n    this.getCell(cell2).removeWall(opposingWallDirection);\n  }\n\n  addInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).setWall(relativeWallDirection);\n    this.getCell(cell2).setWall(opposingWallDirection);\n  }\n\n  hasInterWall(cell1: Position, cell2: Position): boolean {\n    const relativeWall = this.getRelativeDirection(cell1, cell2);\n    const opposingWall = OpposingRectangularDirection[relativeWall];\n    return this.getCell(cell1).hasWall(relativeWall) && this.getCell(cell2).hasWall(opposingWall);\n  }\n\n  isConnected(cell1: Position, cell2: Position): Boolean {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    return this.getCell(cell1).hasWall(relativeWallDirection) && this.getCell(cell2).hasWall(opposingWallDirection);\n  }\n\n  hasWall(position: Position, direction: RectangularDirection) {\n    return this.getCell(position).hasWall(direction);\n  }\n\n  clone() {\n    const board = new Board(this.size.width, this.size.height);\n    for (let i = 0; i < board.cells.length; i++) {\n      board.cells[i] = this.cells[i].clone();\n    }\n    return board;\n  }\n}\n","import {BehaviorSubject, Observable} from \"rxjs\";\nimport {Board} from \"./board\";\nimport {concatMap, filter, share} from \"rxjs/operators\";\nimport {MazeGenerator} from \"../generators\";\nimport {Position} from \"../utils\";\n\n/*--------------\n * Interfaces\n *-------------- */\n\nexport interface BoardOptions {\n  width: number;\n  height: number;\n  generator: MazeGenerator,\n}\n\n/*-------------------\n * Reactive instance\n *------------------- */\n\nconst board$ = new BehaviorSubject<BoardOptions>(null)\n\n\n/*-------------------\n * Actions\n *------------------- */\n\n/**\n * Reset board with last board settings\n */\nexport function resetBoard() {\n  board$.next(board$.getValue());\n}\n\n/**\n * generate a new board with given board `options`\n */\nexport function newBoard(options: BoardOptions) {\n  board$.next(options);\n}\n\n/*-------------------\n * Helpers\n *------------------- */\n\n/**\n * Checks if the given position is last position of cell\n * useful to test game win state\n */\nexport function isLastCell({x, y}: Position): boolean {\n  const {width, height} = board$.getValue();\n  return x === width - 1 && y === height - 1;\n}\n\n/*-------------------\n * Functions\n *------------------- */\n\nexport function mountBoard(): Observable<Board> {\n  return board$\n    .pipe(\n      filter(ev => !!ev),\n      concatMap(async ({width, height, generator}) => {\n        let board = new Board(width, height);\n        return generator.generate(board);\n      }),\n      share(),\n    );\n}\n","import {h} from \"../utils\";\nimport {IRenderer} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {Observable} from \"rxjs\";\nimport {Player} from \"../player\";\n\nexport default class RectangularSvg implements IRenderer {\n  /*\n   * Some rendering options\n   * should some easier way to set them\n   */\n  public cellSize = 30;\n  public lineWidth = 2;\n  public playerPadding = 7;\n\n  constructor() {\n    // setting a css variable for wall animation\n    let root = document.documentElement;\n    root.style.setProperty('--cell-size', this.cellSize + 'px');\n  }\n\n  /**\n   * Renders game board to svg\n   *\n   * The idea is renderer will be initialized only once\n   * and then render function will be called for each new board,\n   * while renderer will take care of player changes without explicitly\n   * rerendering of board.\n   *\n   * @param board individual board snapshot\n   * @param player$ Observable of player position changes\n   */\n  render(board: Board, player$: Observable<Player>): HTMLElement {\n    const width = this.cellSize * (board.size.width + 2) + this.lineWidth;\n    const height = this.cellSize * (board.size.height + 2) + this.lineWidth;\n    const playerEl = this.renderPlayer();\n\n    // listen to player changes and update player on board\n    player$\n      .subscribe(({position}) => {\n        const [x, y] = [position.x, position.y]\n          .map((e) => (this.cellSize * e) + this.playerPadding + this.cellSize);\n\n        playerEl.setAttribute('x', x + '');\n        playerEl.setAttribute('y', y + '');\n      })\n\n    // render path definition string for each cell\n    // and join them to create single path string\n    // for whole board\n    let path = board.cells.map((value) => {\n      return this.renderCell(value, board.size);\n    }).join('');\n\n    return (\n      <svg stroke=\"currentColor\" fill=\"none\" width={width} height={height} viewBox={`0 0 ${width} ${height}`}>\n        {playerEl}\n        <path d={path} class=\"maze-wall\" stroke-width={this.lineWidth} stroke-linecap=\"round\"/>\n      </svg>\n    );\n  }\n\n  /**\n   * Renders player as svg rect\n   */\n  renderPlayer() {\n    const size = this.cellSize - (this.playerPadding * 2);\n    return <rect width={size} height={size} fill=\"currentColor\"\n                 class=\"text-blue-500\"\n                 stroke-width=\"0\" rx=\"3\" id=\"player\"\n                 x={1 + this.playerPadding + this.cellSize} y={1 + this.playerPadding + this.cellSize}/>;\n  }\n\n  /**\n   * Renders a single cell walls to svg path string\n   * @param cell cell to render\n   * @param size board size\n   */\n  renderCell(cell: Cell, size: { width: number, height: number }): string {\n    const pivotX = cell.position.x * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    const pivotY = cell.position.y * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    let path = '';\n\n    if (cell.hasWall(RectangularDirection.UP)) {\n      // Top wall\n      path += `M${pivotX},${pivotY}H${pivotX + this.cellSize}`;\n    }\n\n    if (cell.hasWall(RectangularDirection.LEFT)) {\n      // Left wall\n      path += `M${pivotX},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.x + 1 === size.width && cell.hasWall(RectangularDirection.RIGHT)) {\n      // Right Wall\n      path += `M${pivotX + this.cellSize},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.y + 1 === size.height) {\n      // Bottom Wall\n      path += `M${pivotX},${pivotY + this.cellSize}H${pivotX + this.cellSize}`;\n    }\n\n    return path;\n  }\n}\n","import {IRenderer} from \"./types\";\nimport RectangularSvg from './rectangularSvg';\n\nexport enum Renderers {\n  rectangularSvg\n}\n\nclass RendererManager {\n  private renderers = new Map<Renderers, IRenderer>();\n\n  async loadRenderer(name: Renderers) {\n    if (this.renderers.has(name)) {\n      return this.renderers.get(name);\n    }\n\n    // Just easiest work around for rollup dynamic imports\n    let module;\n    switch (name) {\n      case Renderers.rectangularSvg:\n        module = RectangularSvg;\n        break;\n    }\n\n    const renderer = new module();\n    this.renderers.set(name, renderer);\n    return renderer;\n  }\n}\n\nexport default new RendererManager();\n","import {animationFrameScheduler, BehaviorSubject, merge, Observable} from \"rxjs\";\nimport {Keyboard, Swipe} from \"../browser\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {Position} from \"../utils\";\nimport {filter, map, observeOn, withLatestFrom} from \"rxjs/operators\";\n\n/*------------------\n * Types\n *------------------*/\n\nexport interface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  board$: Observable<Board>;\n}\n\nexport interface Player {\n  state: 'active' | 'inactive' | 'hidden';\n  position: Position;\n}\n\nexport interface Control {\n  dir: RectangularDirection\n}\n\n/*------------------\n * Maps\n *------------------*/\n\nexport const keyMap = {\n  'ArrowRight': RectangularDirection.RIGHT,\n  'ArrowLeft': RectangularDirection.LEFT,\n  'ArrowUp': RectangularDirection.UP,\n  'ArrowDown': RectangularDirection.DOWN,\n}\n\n/*--------------------\n * Reactive instance\n *--------------------*/\n\nconst player$ = new BehaviorSubject<Player>({\n  state: 'active',\n  position: {x: 0, y: 0}\n});\n\n\n/*--------------------\n * Actions\n *--------------------*/\n\n/**\n * Set player Position\n */\nexport function setPlayerPosition(position: Position) {\n  const {state} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Set player Position\n */\nexport function setPlayerState(state: 'active' | 'inactive' | 'hidden') {\n  const {position} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Move player in given direction\n */\nexport function moveInDirection(dir: RectangularDirection, board: Board) {\n  let {position: {x, y}} = player$.getValue();\n\n  // continue to moving player in the direction until cell is a passage\n  do {\n    if (dir === RectangularDirection.RIGHT && x < (board.size.width - 1)) {\n      x++;\n    } else if (dir === RectangularDirection.LEFT && x > 0) {\n      x--;\n    } else if (dir === RectangularDirection.UP && y > 0) {\n      y--;\n    } else if (dir === RectangularDirection.DOWN && y < (board.size.height - 1)) {\n      y++;\n    }\n\n    const visitable = board.getNeighbourCells({x, y}, true);\n    if (!visitable.has(dir) || visitable.size > 2) {\n      break;\n    }\n  } while (true);\n\n  setPlayerPosition({x, y});\n}\n\n/*--------------------\n * Functions\n *--------------------*/\n\n/**\n * Mount player to game logic\n *\n * returns a observable player\n */\nexport function mountPlayer(\n  {keyboard$, swipe$, board$}: MountOptions\n): Observable<Player> {\n\n  // reset player whenever new board is emitted\n  board$.subscribe(() => {\n    const {position: {x, y}} = player$.getValue();\n    if (x !== 0 || y !== 0) {\n      setPlayerPosition({x: 0, y: 0})\n    }\n  })\n\n  // combine touch and keyboard events\n  const control$: Observable<Control> = merge(\n    keyboard$,\n    swipe$,\n  ).pipe(\n    map((dir) => {\n      if ((dir as Keyboard).type) {\n        // @ts-ignore\n        return {dir: keyMap[dir.type]}\n      }\n      return dir as Swipe;\n    })\n  )\n\n  control$\n    .pipe(\n      withLatestFrom(board$),\n      // don't move player if there is a wall in control direction\n      // or player is not active\n      filter(([{dir}, board]) => {\n        const {position: {x, y}, state} = player$.getValue();\n        return state === 'active' && !board.hasWall({x, y}, dir);\n      })\n    )\n    .subscribe(([{dir}, board]) => {\n      moveInDirection(dir, board)\n    });\n\n  // use animationFrameScheduler to ensure smooth animations\n  return player$.pipe(\n    observeOn(animationFrameScheduler)\n  )\n}\n","import {watchKeyboard, watchSwipe} from \"./browser\";\nimport {Generators} from './generators';\nimport {newBoard, resetBoard} from \"./board\";\nimport {fromEvent} from \"rxjs\";\nimport {mountGame} from \"./game\";\n\n/*\n * References to some required document elements\n * Technically this should be done after DOM Content Loaded\n * But for some reason its working :)\n */\nconst boardEl = document.getElementById('board');\nconst boardWrapperEl = document.getElementById('boardWrapper');\nconst ResetEl = document.getElementById('reset');\n\n\n/* initialize all the observables */\nconst keyboard$ = watchKeyboard();\nconst swipe$ = watchSwipe(boardWrapperEl);\n\nmountGame({keyboard$, swipe$, boardEl});\n\n/*\n * Initialize board with initial options.\n * Every other price of the board depends on\n * some non-null value of board option\n */\nnewBoard({\n  height: 15,\n  width: 15,\n  generator: Generators.RecursiveBackTrack,\n});\n\n\n/* Bind events with buttons */\nfromEvent(ResetEl, 'click')\n  .subscribe(resetBoard);\n","import {Size} from \"../utils\";\nimport {MazeGenerator} from \"../generators\";\nimport renderersManager, {Renderers} from \"../renderers\";\nimport {Observable} from \"rxjs\";\nimport {Keyboard} from \"../browser/keyboard\";\nimport {Swipe} from \"../browser/touch\";\nimport {isLastCell, mountBoard, resetBoard} from \"../board\";\nimport {mountPlayer, setPlayerPosition, setPlayerState} from \"../player\";\nimport {removeElementChildren} from \"../browser/element\";\nimport {filter} from \"rxjs/operators\";\nimport {default as canvasConfetti} from \"canvas-confetti\";\n\nexport interface GameOptions {\n  size: Size;\n  generator: MazeGenerator;\n  renderer: Renderers;\n  interactive: boolean;\n  showPlayer: boolean;\n}\n\ninterface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  boardEl: HTMLElement;\n}\n\n/**\n * Handle keyboard shortcuts\n */\nfunction registerShortcuts(keyboard$: Observable<Keyboard>) {\n  keyboard$.subscribe(({type}) => {\n    /* 'r' to reset game */\n    if (type.toLowerCase() === 'r') {\n      resetBoard();\n    }\n  })\n}\n\nexport function mountGame({keyboard$, swipe$, boardEl}: MountOptions) {\n  registerShortcuts(keyboard$);\n\n  const board$ = mountBoard();\n  const player$ = mountPlayer({keyboard$, board$, swipe$});\n\n  /* render board whenever new board is emitted */\n  board$\n    .subscribe((board) => {\n      setPlayerState('active');\n      renderersManager.loadRenderer(Renderers.rectangularSvg).then((render) => {\n        removeElementChildren(boardEl);\n        boardEl.appendChild(\n          render.render(board, player$)\n        );\n      })\n    });\n\n  player$\n    .pipe(\n      filter(({position, state}) => isLastCell(position) && state === 'active'),\n    )\n    .subscribe(async ({position: {x, y}}) => {\n      const start = new Date().getTime();\n      setPlayerState('inactive');\n\n      let confetti: typeof canvasConfetti;\n      try {\n        const canvasConfetti = await import('canvas-confetti');\n        confetti = canvasConfetti.default;\n      } catch (e) {\n        console.error(e);\n      }\n\n      const timeDiff = new Date().getTime() - start;\n      if (timeDiff >= 250) {\n        setPlayerPosition({x: x + 1, y});\n\n        if (confetti)\n          confetti({origin: {y: 0.8}, particleCount: 100}).then();\n      } else {\n        setTimeout(() => {\n          setPlayerPosition({x: x + 1, y});\n          if (confetti)\n            confetti({origin: {y: 0.8}, particleCount: 100}).then();\n        }, 250 - timeDiff);\n      }\n    });\n}\n","/**\n * Retrieve the currently active element\n *\n * @returns Element or nothing\n */\nexport function getActiveElement(): HTMLElement | undefined {\n  return document.activeElement instanceof HTMLElement\n    ? document.activeElement\n    : undefined\n}\n\n\n/**\n * Remove all the children of given element\n */\nexport function removeElementChildren(element: HTMLElement): void {\n  while (element.lastElementChild) {\n    element.removeChild(element.lastElementChild);\n  }\n}\n","import {fromEvent, Observable} from \"rxjs\";\nimport {filter, map, share} from \"rxjs/operators\";\nimport {getActiveElement} from \"../element\";\n\n/**\n * Keyboard\n */\nexport interface Keyboard {\n  type: string                         /* Key type */\n  claim(): void                        /* Key claim */\n}\n\n/**\n * Check whether an element may receive keyboard input\n *\n * @param el - Element\n *\n * @returns Test result\n */\nfunction isSusceptibleToKeyboard(el: HTMLElement): boolean {\n  switch (el.tagName) {\n    /* Form elements */\n    case \"INPUT\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      return true\n\n    /* Everything else */\n    default:\n      return el.isContentEditable\n  }\n}\n\n/**\n * Watch keyboard\n *\n * @returns Keyboard observable\n */\nexport function watchKeyboard(): Observable<Keyboard> {\n  return fromEvent<KeyboardEvent>(window, \"keydown\")\n    .pipe(\n      filter(ev => !(ev.metaKey || ev.ctrlKey)),\n      map(ev => ({\n        type: ev.key,\n        claim() {\n          ev.preventDefault()\n          ev.stopPropagation()\n        }\n      } as Keyboard)),\n      filter(() => {\n        const active = getActiveElement()\n        if (typeof active !== \"undefined\")\n          return !isSusceptibleToKeyboard(active)\n\n        return true\n      }),\n      share(),\n    )\n}\n","import {from, fromEvent, merge, NEVER, Observable} from \"rxjs\";\nimport {map, share, switchMap} from \"rxjs/operators\";\nimport {RectangularDirection} from \"../../board\";\n\nexport interface Swipe {\n  dir: RectangularDirection;\n}\n\n/**\n * Watch swipe events on the given element using hammerjs\n */\nexport function watchSwipe(element = document.documentElement): Observable<Swipe> {\n  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n\n  if (!isTouchDevice) {\n    return NEVER;\n  }\n\n  return from(import('hammerjs'))\n    .pipe(\n      switchMap((hammer) => {\n        const mc = new hammer.Manager(element);\n        mc.add(new hammer.Swipe());\n\n        return merge(\n          fromEvent(mc, 'swipeleft'),\n          fromEvent(mc, 'swiperight'),\n          fromEvent(mc, 'swipeup'),\n          fromEvent(mc, 'swipedown'),\n        )\n      }),\n      map(({type}) => {\n        return {dir: type.slice(5)};\n      }),\n      share(),\n    )\n}\n"],"names":["positionToIndex","position","width","y","x","stringifyPosition","CellSet","Map","[object Object]","cells","super","this","addAll","cell","set","add","has","delete","remove","Array","from","values","Math","round","random","length","appendChild","el","child","innerHTML","toString","Node","isArray","node","h","tag","attributes","children","svgTags","includes","document","createElementNS","createElement","attr","Object","keys","setAttribute","shuffle","array","temporaryValue","randomIndex","currentIndex","floor","PathSetGenerator","pathSets","hasCell","cell1","cell2","set1","getSetFromCell","set2","i","indexOf","splice","push","MarkovDecision","env","gamma","ValueTable","Float32Array","stateSize","PolicyTable","maxActions","s","possibilities","allowedActions","possibility","state","ps","action","prob","probabilities","r","c","sampleWeighted","evaluatePolicy","updatePolicy","newValueTable","v","nextState","reward","vMax","nMax","vs","getUnvisitedCell","board","visitedCells","getRandomInt","min","max","stateToXY","size","height","xyToState","randomWalkUntil","until","walkInVisited","path","model","actions","getCell","learn","direction","act","getNeighbourCell","Generators","RecursiveBackTrack","clone","removeWall","randomCell","getRandomCell","visitCell","neighbourCells","getNeighbourCells","removeInterWall","AldousBroder","currentCell","movingTowards","cellNeighbours","filter","unvisitedCells","dx","sign","dy","BinaryTree","topBias","rightBias","dir","getRelativeDirection","Eller","visitRow","visitNextRow","index","mergeAll","isFromSameSet","joinCellSets","setCells","entries","key","map","n","nextCell","Kruskal","neighbours","randomNeighbour","HuntAndKill","some","hunt","neighbourCell","PrimsRandomization","getRandom","randomCellNeighbours","randomCellNeighbour","removeAll","Wilson","Sidewinder","joinedCells","OpposingRectangularDirection","0","1","2","3","Cell","walls","setAllWalls","setWall","get","hasWall","Board","initCells","visitableOnly","visitableNeighbours","hasInterWall","relativeWallDirection","opposingWallDirection","relativeWall","opposingWall","board$","BehaviorSubject","resetBoard","next","getValue","isLastCell","mountBoard","pipe","ev","concatMap","async","generator","generate","share","RectangularSvg","documentElement","style","setProperty","cellSize","player$","lineWidth","playerEl","renderPlayer","subscribe","e","playerPadding","value","renderCell","join","stroke","fill","viewBox","d","class","rx","id","pivotX","pivotY","Renderers","name","renderers","module","rectangularSvg","renderer","keyMap","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","setPlayerPosition","setPlayerState","mountPlayer","keyboard$","swipe$","merge","type","withLatestFrom","visitable","moveInDirection","observeOn","animationFrameScheduler","boardEl","getElementById","boardWrapperEl","ResetEl","options","toLowerCase","registerShortcuts","renderersManager","loadRenderer","then","render","element","lastElementChild","removeChild","removeElementChildren","start","Date","getTime","confetti","canvasConfetti","import","default","console","error","timeDiff","origin","particleCount","setTimeout","mountGame","fromEvent","window","metaKey","ctrlKey","preventDefault","stopPropagation","active","activeElement","HTMLElement","undefined","tagName","isContentEditable","isSusceptibleToKeyboard","navigator","maxTouchPoints","msMaxTouchPoints","switchMap","hammer","mc","Manager","Swipe","slice","NEVER","watchSwipe"],"mappings":"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"}