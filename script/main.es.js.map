{"version":3,"file":"main.es.js","sources":["../../src/utils/h/svgTags.ts","../../src/utils/h/index.ts","../../src/utils/point.ts","../../src/generators/index.ts","../../src/generators/recursiveBackTrack.ts","../../src/board/cell.ts","../../src/board/board.ts","../../src/board/_.ts","../../src/renderers/rectangularSvg.tsx","../../src/renderers/index.ts","../../src/player/index.ts","../../src/main.ts","../../src/game/index.ts","../../src/browser/element/index.ts","../../src/browser/keyboard/index.ts","../../src/browser/touch/index.ts"],"sourcesContent":["export default [\"circle\", \"defs\", \"ellipse\", \"filter\", \"g\", \"line\", \"path\", \"rect\", \"svg\"]\n","/*\n * Adopted from https://github.com/squidfunk/mkdocs-material/blob/master/src/assets/javascripts/utilities/h/index.ts\n * with additional support for svg elements\n */\n\nimport {JSX as JSXInternal} from \"preact\"\nimport svgTags from \"./svgTags\";\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes =\n  & JSXInternal.HTMLAttributes\n  & JSXInternal.SVGAttributes\n  & Record<string, any>\n\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nfunction appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory\n *\n * @param tag - HTML tag\n * @param attributes - HTML attributes\n * @param children - Child elements\n *\n * @returns Element\n */\nexport function h(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(attr, attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(attr, \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n\n\n/* This override is necessary for types to work */\nexport declare namespace h {\n  namespace JSX {\n    type Element = HTMLElement\n    type IntrinsicElements = JSXInternal.IntrinsicElements\n  }\n}\n","export interface Position {\n  readonly x: number;\n  readonly y: number;\n}\n\n/**\n * Convert a position (2d) to linear index\n */\nexport function positionToIndex(position: Position, width: number): number {\n  return position.y * width + position.x;\n}\n\nexport function stringifyPosition(position: Position) {\n  return `${position.x}-${position.y}`;\n}\n","import RecursiveBacktrack from \"./recursiveBackTrack\";\n\nexport * from './types';\n\nexport const Generators = {\n  recursiveBackTrack: new RecursiveBacktrack()\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {Generator} from \"./types\";\nimport {stringifyPosition} from \"../utils\";\n\n/**\n * Depth first recursive backtrack maze generation algorithm\n * https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n *\n * Generates long dead ends making the solution little difficult\n */\nexport default class RecursiveBacktrack implements Generator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new Set<string>();\n    const randomCell = board.getRandomCell();\n\n    this.visitCell(randomCell, visitedCells, board);\n    return board;\n  }\n\n  visitCell(cell: Cell, visitedCells: Set<string>, board: Board) {\n    visitedCells.add(stringifyPosition(cell.position));\n    const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n\n    while (neighbourCells.length !== 0) {\n      // select a random neighbour\n      const i = Math.round(Math.random() * (neighbourCells.length - 1));\n      const randomCell = neighbourCells[i];\n\n      // if random neighbour is not already visited remove wall between\n      // random neighbour and current cell and recursively visit that neighbour\n      if (!visitedCells.has(stringifyPosition(randomCell.position))) {\n        board.removeInterWall(cell.position, randomCell.position);\n        this.visitCell(randomCell, visitedCells, board);\n      }\n\n      // after visit remove random neighbour from neighbourCells\n      neighbourCells.splice(i, 1);\n    }\n  }\n}\n","import {Position} from \"../utils\";\n\nexport const enum RectangularDirection {\n  LEFT = 'left',\n  RIGHT = 'right',\n  UP = 'up',\n  DOWN = 'down',\n}\n\nexport const OpposingRectangularDirection = {\n  [RectangularDirection.LEFT]: RectangularDirection.RIGHT,\n  [RectangularDirection.RIGHT]: RectangularDirection.LEFT,\n  [RectangularDirection.UP]: RectangularDirection.DOWN,\n  [RectangularDirection.DOWN]: RectangularDirection.UP,\n};\n\nexport class Cell {\n  public readonly walls: Map<RectangularDirection, boolean>;\n\n  constructor(public readonly position: Position) {\n    this.walls = new Map<RectangularDirection, boolean>();\n    this.setAllWalls();\n  }\n\n  setAllWalls() {\n    this.setWall(RectangularDirection.UP);\n    this.setWall(RectangularDirection.RIGHT);\n    this.setWall(RectangularDirection.DOWN);\n    this.setWall(RectangularDirection.LEFT);\n  }\n\n  removeAllWalls() {\n    this.removeWall(RectangularDirection.UP);\n    this.removeWall(RectangularDirection.RIGHT);\n    this.removeWall(RectangularDirection.DOWN);\n    this.removeWall(RectangularDirection.LEFT);\n  }\n\n  setWall(dir: RectangularDirection) {\n    this.walls.set(dir, true);\n  }\n\n  removeWall(dir: RectangularDirection) {\n    this.walls.set(dir, false);\n  }\n\n  hasWall(dir: RectangularDirection): boolean {\n    return this.walls.get(dir);\n  }\n\n  clone() {\n    const cell = new Cell(this.position);\n    for (const [dir, hasWall] of this.walls.entries()) {\n      cell.walls.set(dir, hasWall);\n    }\n    return cell;\n  }\n}\n","import {Cell, OpposingRectangularDirection, RectangularDirection} from './cell';\nimport {Position, positionToIndex, Size} from \"../utils\";\n\nexport class Board {\n  public readonly cells: Array<Cell>;\n  public readonly size: Size;\n\n  constructor(width: number, height: number) {\n    this.size = {height, width};\n    this.cells = [];\n    this.initCells();\n  }\n\n  private initCells() {\n    for (let y = 0; y < this.size.height; y++) {\n      for (let x = 0; x < this.size.width; x++) {\n        this.cells.push(new Cell({x, y}));\n      }\n    }\n  }\n\n  getRandomCell(): Cell {\n    return this.cells[Math.round(Math.random() * (this.cells.length - 1))];\n  }\n\n  private getCell(position: Position): Cell {\n    return this.cells[positionToIndex(position, this.size.width)];\n  }\n\n  getNeighbourCells(position: Position, visitableOnly: boolean = false): Map<RectangularDirection, Cell> {\n    let neighbours = new Map<RectangularDirection, Cell>(),\n      index = positionToIndex(position, this.size.width);\n\n    if (index >= this.size.width) {\n      const cell = this.cells[index - this.size.width];\n      neighbours.set(RectangularDirection.UP, cell);\n    }\n\n    if ((index + 1) % this.size.width != 0) {\n      const cell = this.cells[index + 1];\n      neighbours.set(RectangularDirection.RIGHT, cell);\n    }\n\n    if (index < this.cells.length - this.size.width) {\n      const cell = this.cells[index + this.size.width];\n      neighbours.set(RectangularDirection.DOWN, cell);\n    }\n\n    if (index % this.size.width != 0) {\n      const cell = this.cells[index - 1];\n      neighbours.set(RectangularDirection.LEFT, cell);\n    }\n\n    if (visitableOnly) {\n      const visitableNeighbours = Array.from(neighbours.entries())\n        .filter(([dir, cell]) => {\n          return !this.hasInterWall(cell.position, position);\n        });\n\n      neighbours = new Map(visitableNeighbours);\n    }\n\n    return neighbours;\n  }\n\n  getNeighbourCell(position: Position, direction: RectangularDirection): Cell {\n    const cells = this.getNeighbourCells(position);\n    return cells.get(direction);\n  }\n\n  getRelativeDirection(cell1: Position, cell2: Position): RectangularDirection {\n    if (cell1.y === cell2.y + 1) {\n      return RectangularDirection.UP;\n    }\n    if (cell1.x === cell2.x - 1) {\n      return RectangularDirection.RIGHT;\n    }\n    if (cell1.x === cell2.x + 1) {\n      return RectangularDirection.LEFT;\n    }\n    if (cell1.y === cell2.y - 1) {\n      return RectangularDirection.DOWN;\n    }\n    throw `'${cell1}' and '${cell2}' are not neighbours`;\n  }\n\n  removeInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).removeWall(relativeWallDirection);\n    this.getCell(cell2).removeWall(opposingWallDirection);\n  }\n\n  addInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).setWall(relativeWallDirection);\n    this.getCell(cell2).setWall(opposingWallDirection);\n  }\n\n  hasInterWall(cell1: Position, cell2: Position): boolean {\n    const relativeWall = this.getRelativeDirection(cell1, cell2);\n    const opposingWall = OpposingRectangularDirection[relativeWall];\n    return this.getCell(cell1).hasWall(relativeWall) && this.getCell(cell2).hasWall(opposingWall);\n  }\n\n  isConnected(cell1: Position, cell2: Position): Boolean {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    return this.getCell(cell1).hasWall(relativeWallDirection) && this.getCell(cell2).hasWall(opposingWallDirection);\n  }\n\n  hasWall(position: Position, direction: RectangularDirection) {\n    return this.getCell(position).hasWall(direction);\n  }\n\n  clone() {\n    const board = new Board(this.size.width, this.size.height);\n    for (let i = 0; i < board.cells.length; i++) {\n      board.cells[i] = this.cells[i].clone();\n    }\n    return board;\n  }\n}\n","import {BehaviorSubject, Observable} from \"rxjs\";\nimport {Board} from \"./board\";\nimport {concatMap, filter, share} from \"rxjs/operators\";\nimport {Generator} from \"../generators\";\nimport {Position} from \"../utils\";\n\n/*--------------\n * Interfaces\n *-------------- */\n\nexport interface BoardOptions {\n  width: number;\n  height: number;\n  generator: Generator,\n}\n\n/*-------------------\n * Reactive instance\n *------------------- */\n\nconst board$ = new BehaviorSubject<BoardOptions>(null)\n\n\n/*-------------------\n * Actions\n *------------------- */\n\n/**\n * Reset board with last board settings\n */\nexport function resetBoard() {\n  board$.next(board$.getValue());\n}\n\n/**\n * generate a new board with given board `options`\n */\nexport function newBoard(options: BoardOptions) {\n  board$.next(options);\n}\n\n/*-------------------\n * Helpers\n *------------------- */\n\n/**\n * Checks if the given position is last position of cell\n * useful to test game win state\n */\nexport function isLastCell({x, y}: Position): boolean {\n  const {width, height} = board$.getValue();\n  return x === width - 1 && y === height - 1;\n}\n\n/*-------------------\n * Functions\n *------------------- */\n\nexport function mountBoard(): Observable<Board> {\n  return board$\n    .pipe(\n      filter(ev => !!ev),\n      concatMap(async ({width, height, generator}) => {\n        let board = new Board(width, height);\n        return generator.generate(board);\n      }),\n      share(),\n    );\n}\n","import {h} from \"../utils\";\nimport {IRenderer} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {Observable} from \"rxjs\";\nimport {Player} from \"../player\";\n\nexport default class RectangularSvg implements IRenderer {\n  /*\n   * Some rendering options\n   * should some easier way to set them\n   */\n  public cellSize = 30;\n  public lineWidth = 2;\n  public playerPadding = 7;\n\n  constructor() {\n    // setting a css variable for wall animation\n    let root = document.documentElement;\n    root.style.setProperty('--cell-size', this.cellSize + 'px');\n  }\n\n  /**\n   * Renders game board to svg\n   *\n   * The idea is renderer will be initialized only once\n   * and then render function will be called for each new board,\n   * while renderer will take care of player changes without explicitly\n   * rerendering of board.\n   *\n   * @param board individual board snapshot\n   * @param player$ Observable of player position changes\n   */\n  render(board: Board, player$: Observable<Player>): HTMLElement {\n    const width = this.cellSize * (board.size.width + 2) + this.lineWidth;\n    const height = this.cellSize * (board.size.height + 2) + this.lineWidth;\n    const playerEl = this.renderPlayer();\n\n    // listen to player changes and update player on board\n    player$\n      .subscribe(({position}) => {\n        const [x, y] = [position.x, position.y]\n          .map((e) => (this.cellSize * e) + this.playerPadding + this.cellSize);\n\n        playerEl.setAttribute('x', x + '');\n        playerEl.setAttribute('y', y + '');\n      })\n\n    // render path definition string for each cell\n    // and join them to create single path string\n    // for whole board\n    let path = board.cells.map((value) => {\n      return this.renderCell(value, board.size);\n    }).join('');\n\n    return (\n      <svg stroke=\"currentColor\" fill=\"none\" width={width} height={height} viewBox={`0 0 ${width} ${height}`}>\n        {playerEl}\n        <path d={path} class=\"maze-wall\" stroke-width={this.lineWidth} stroke-linecap=\"round\"/>\n      </svg>\n    );\n  }\n\n  /**\n   * Renders player as svg rect\n   */\n  renderPlayer() {\n    const size = this.cellSize - (this.playerPadding * 2);\n    return <rect width={size} height={size} fill=\"currentColor\"\n                 class=\"text-blue-500\"\n                 stroke-width=\"0\" rx=\"3\" id=\"player\"\n                 x={1 + this.playerPadding + this.cellSize} y={1 + this.playerPadding + this.cellSize}/>;\n  }\n\n  /**\n   * Renders a single cell walls to svg path string\n   * @param cell cell to render\n   * @param size board size\n   */\n  renderCell(cell: Cell, size: { width: number, height: number }): string {\n    const pivotX = cell.position.x * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    const pivotY = cell.position.y * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    let path = '';\n\n    if (cell.hasWall(RectangularDirection.UP)) {\n      // Top wall\n      path += `M${pivotX},${pivotY}H${pivotX + this.cellSize}`;\n    }\n\n    if (cell.hasWall(RectangularDirection.LEFT)) {\n      // Left wall\n      path += `M${pivotX},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.x + 1 === size.width && cell.hasWall(RectangularDirection.RIGHT)) {\n      // Right Wall\n      path += `M${pivotX + this.cellSize},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.y + 1 === size.height) {\n      // Bottom Wall\n      path += `M${pivotX},${pivotY + this.cellSize}H${pivotX + this.cellSize}`;\n    }\n\n    return path;\n  }\n}\n","import {IRenderer} from \"./types\";\nimport RectangularSvg from './rectangularSvg';\n\nexport enum Renderers {\n  rectangularSvg\n}\n\nclass RendererManager {\n  private renderers = new Map<Renderers, IRenderer>();\n\n  async loadRenderer(name: Renderers) {\n    if (this.renderers.has(name)) {\n      return this.renderers.get(name);\n    }\n\n    // Just easiest work around for rollup dynamic imports\n    let module;\n    switch (name) {\n      case Renderers.rectangularSvg:\n        module = RectangularSvg;\n        break;\n    }\n\n    const renderer = new module();\n    this.renderers.set(name, renderer);\n    return renderer;\n  }\n}\n\nexport default new RendererManager();\n","import {animationFrameScheduler, BehaviorSubject, merge, Observable} from \"rxjs\";\nimport {Keyboard, Swipe} from \"../browser\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {Position} from \"../utils\";\nimport {filter, map, observeOn, withLatestFrom} from \"rxjs/operators\";\n\n/*------------------\n * Types\n *------------------*/\n\nexport interface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  board$: Observable<Board>;\n}\n\nexport interface Player {\n  state: 'active' | 'inactive' | 'hidden';\n  position: Position;\n}\n\nexport interface Control {\n  dir: RectangularDirection\n}\n\n/*------------------\n * Maps\n *------------------*/\n\nexport const keyMap = {\n  'ArrowRight': RectangularDirection.RIGHT,\n  'ArrowLeft': RectangularDirection.LEFT,\n  'ArrowUp': RectangularDirection.UP,\n  'ArrowDown': RectangularDirection.DOWN,\n}\n\n/*--------------------\n * Reactive instance\n *--------------------*/\n\nconst player$ = new BehaviorSubject<Player>({\n  state: 'active',\n  position: {x: 0, y: 0}\n});\n\n\n/*--------------------\n * Actions\n *--------------------*/\n\n/**\n * Set player Position\n */\nexport function setPlayerPosition(position: Position) {\n  const {state} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Set player Position\n */\nexport function setPlayerState(state: 'active' | 'inactive' | 'hidden') {\n  const {position} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Move player in given direction\n */\nexport function moveInDirection(dir: RectangularDirection, board: Board) {\n  let {position: {x, y}} = player$.getValue();\n\n  // continue to moving player in the direction until cell is a passage\n  do {\n    if (dir === 'right' && x < (board.size.width - 1)) {\n      x++;\n    } else if (dir === 'left' && x > 0) {\n      x--;\n    } else if (dir === 'up' && y > 0) {\n      y--;\n    } else if (dir === 'down' && y < (board.size.height - 1)) {\n      y++;\n    }\n\n    const visitable = board.getNeighbourCells({x, y}, true);\n    if (!visitable.has(dir) || visitable.size > 2) {\n      break;\n    }\n  } while (true);\n\n  setPlayerPosition({x, y});\n}\n\n/*--------------------\n * Functions\n *--------------------*/\n\n/**\n * Mount player to game logic\n *\n * returns a observable player\n */\nexport function mountPlayer(\n  {keyboard$, swipe$, board$}: MountOptions\n): Observable<Player> {\n\n  // reset player whenever new board is emitted\n  board$.subscribe(() => {\n    const {position: {x, y}} = player$.getValue();\n    if (x !== 0 || y !== 0) {\n      setPlayerPosition({x: 0, y: 0})\n    }\n  })\n\n  // combine touch and keyboard events\n  const control$: Observable<Control> = merge(\n    keyboard$,\n    swipe$,\n  ).pipe(\n    map((dir) => {\n      if ((dir as Keyboard).type) {\n        // @ts-ignore\n        return {dir: keyMap[dir.type]}\n      }\n      return dir as Swipe;\n    })\n  )\n\n  control$\n    .pipe(\n      withLatestFrom(board$),\n      // don't move player if there is a wall in control direction\n      // or player is not active\n      filter(([{dir}, board]) => {\n        const {position: {x, y}, state} = player$.getValue();\n        return state === 'active' && !board.hasWall({x, y}, dir);\n      })\n    )\n    .subscribe(([{dir}, board]) => {\n      moveInDirection(dir, board)\n    });\n\n  // use animationFrameScheduler to ensure smooth animations\n  return player$.pipe(\n    observeOn(animationFrameScheduler)\n  )\n}\n","import {watchKeyboard, watchSwipe} from \"./browser\";\nimport {Generators} from './generators';\nimport {newBoard, resetBoard} from \"./board\";\nimport {fromEvent} from \"rxjs\";\nimport {mountGame} from \"./game\";\n\n/*\n * References to some required document elements\n * Technically this should be done after DOM Content Loaded\n * But for some reason its working :)\n */\nconst boardEl = document.getElementById('board');\nconst boardWrapperEl = document.getElementById('boardWrapper');\nconst ResetEl = document.getElementById('reset');\n\n\n/* initialize all the observables */\nconst keyboard$ = watchKeyboard();\nconst swipe$ = watchSwipe(boardWrapperEl);\n\nmountGame({keyboard$, swipe$, boardEl});\n\n/*\n * Initialize board with initial options.\n * Every other price of the board depends on\n * some non-null value of board option\n */\nnewBoard({\n  height: 5,\n  width: 5,\n  generator: Generators.recursiveBackTrack,\n});\n\n\n/* Bind events with buttons */\nfromEvent(ResetEl, 'click')\n  .subscribe(resetBoard);\n","import {Size} from \"../utils\";\nimport {Generator} from \"../generators\";\nimport renderersManager, {Renderers} from \"../renderers\";\nimport {Observable} from \"rxjs\";\nimport {Keyboard} from \"../browser/keyboard\";\nimport {Swipe} from \"../browser/touch\";\nimport {isLastCell, mountBoard, resetBoard} from \"../board\";\nimport {mountPlayer, setPlayerPosition, setPlayerState} from \"../player\";\nimport {removeElementChildren} from \"../browser/element\";\nimport {filter} from \"rxjs/operators\";\nimport {default as canvasConfetti} from \"canvas-confetti\";\n\nexport interface GameOptions {\n  size: Size;\n  generator: Generator;\n  renderer: Renderers;\n  interactive: boolean;\n  showPlayer: boolean;\n}\n\ninterface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  boardEl: HTMLElement;\n}\n\n/**\n * Handle keyboard shortcuts\n */\nfunction registerShortcuts(keyboard$: Observable<Keyboard>) {\n  keyboard$.subscribe(({type}) => {\n    /* 'r' to reset game */\n    if (type.toLowerCase() === 'r') {\n      resetBoard();\n    }\n  })\n}\n\nexport function mountGame({keyboard$, swipe$, boardEl}: MountOptions) {\n  registerShortcuts(keyboard$);\n\n  const board$ = mountBoard();\n  const player$ = mountPlayer({keyboard$, board$, swipe$});\n\n  /* render board whenever new board is emitted */\n  board$\n    .subscribe((board) => {\n      setPlayerState('active');\n      renderersManager.loadRenderer(Renderers.rectangularSvg).then((render) => {\n        removeElementChildren(boardEl);\n        boardEl.appendChild(\n          render.render(board, player$)\n        );\n      })\n    });\n\n  player$\n    .pipe(\n      filter(({position, state}) => isLastCell(position) && state === 'active'),\n    )\n    .subscribe(async ({position: {x, y}}) => {\n      const start = new Date().getTime();\n      setPlayerState('inactive');\n\n      let confetti: typeof canvasConfetti;\n      try {\n        const canvasConfetti = await import('canvas-confetti');\n        confetti = canvasConfetti.default;\n      } catch (e) {\n        console.error(e);\n      }\n\n      const timeDiff = new Date().getTime() - start;\n      if (timeDiff >= 250) {\n        setPlayerPosition({x: x + 1, y});\n\n        if (confetti)\n          confetti({origin: {y: 0.8}, particleCount: 100}).then();\n      } else {\n        setTimeout(() => {\n          setPlayerPosition({x: x + 1, y});\n          if (confetti)\n            confetti({origin: {y: 0.8}, particleCount: 100}).then();\n        }, 250 - timeDiff);\n      }\n    });\n}\n","/**\n * Retrieve the currently active element\n *\n * @returns Element or nothing\n */\nexport function getActiveElement(): HTMLElement | undefined {\n  return document.activeElement instanceof HTMLElement\n    ? document.activeElement\n    : undefined\n}\n\n\n/**\n * Remove all the children of given element\n */\nexport function removeElementChildren(element: HTMLElement): void {\n  while (element.lastElementChild) {\n    element.removeChild(element.lastElementChild);\n  }\n}\n","import {fromEvent, Observable} from \"rxjs\";\nimport {filter, map, share} from \"rxjs/operators\";\nimport {getActiveElement} from \"../element\";\n\n/**\n * Keyboard\n */\nexport interface Keyboard {\n  type: string                         /* Key type */\n  claim(): void                        /* Key claim */\n}\n\n/**\n * Check whether an element may receive keyboard input\n *\n * @param el - Element\n *\n * @returns Test result\n */\nfunction isSusceptibleToKeyboard(el: HTMLElement): boolean {\n  switch (el.tagName) {\n    /* Form elements */\n    case \"INPUT\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      return true\n\n    /* Everything else */\n    default:\n      return el.isContentEditable\n  }\n}\n\n/**\n * Watch keyboard\n *\n * @returns Keyboard observable\n */\nexport function watchKeyboard(): Observable<Keyboard> {\n  return fromEvent<KeyboardEvent>(window, \"keydown\")\n    .pipe(\n      filter(ev => !(ev.metaKey || ev.ctrlKey)),\n      map(ev => ({\n        type: ev.key,\n        claim() {\n          ev.preventDefault()\n          ev.stopPropagation()\n        }\n      } as Keyboard)),\n      filter(() => {\n        const active = getActiveElement()\n        if (typeof active !== \"undefined\")\n          return !isSusceptibleToKeyboard(active)\n\n        return true\n      }),\n      share(),\n    )\n}\n","import {from, fromEvent, merge, NEVER, Observable} from \"rxjs\";\nimport {map, share, switchMap} from \"rxjs/operators\";\nimport {RectangularDirection} from \"../../board\";\n\nexport interface Swipe {\n  dir: RectangularDirection;\n}\n\n/**\n * Watch swipe events on the given element using hammerjs\n */\nexport function watchSwipe(element = document.documentElement): Observable<Swipe> {\n  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n\n  if (!isTouchDevice) {\n    return NEVER;\n  }\n\n  return from(import('hammerjs'))\n    .pipe(\n      switchMap((hammer) => {\n        const mc = new hammer.Manager(element);\n        mc.add(new hammer.Swipe());\n\n        return merge(\n          fromEvent(mc, 'swipeleft'),\n          fromEvent(mc, 'swiperight'),\n          fromEvent(mc, 'swipeup'),\n          fromEvent(mc, 'swipedown'),\n        )\n      }),\n      map(({type}) => {\n        return {dir: type.slice(5)};\n      }),\n      share(),\n    )\n}\n"],"names":["appendChild","el","child","innerHTML","toString","Node","Array","isArray","node","h","tag","attributes","children","svgTags","includes","document","createElementNS","createElement","attr","Object","keys","setAttribute","positionToIndex","position","width","y","x","stringifyPosition","Generators","recursiveBackTrack","[object Object]","board","clone","cells","removeWall","length","visitedCells","Set","randomCell","getRandomCell","this","visitCell","cell","add","neighbourCells","from","getNeighbourCells","values","i","Math","round","random","has","removeInterWall","splice","OpposingRectangularDirection","left","right","up","down","Cell","walls","Map","setAllWalls","setWall","dir","set","get","hasWall","entries","Board","height","size","initCells","push","visitableOnly","neighbours","index","visitableNeighbours","filter","hasInterWall","direction","cell1","cell2","relativeWallDirection","getRelativeDirection","opposingWallDirection","getCell","relativeWall","opposingWall","board$","BehaviorSubject","resetBoard","next","getValue","isLastCell","mountBoard","pipe","ev","concatMap","async","generator","generate","share","RectangularSvg","documentElement","style","setProperty","cellSize","player$","lineWidth","playerEl","renderPlayer","subscribe","map","e","playerPadding","path","value","renderCell","join","stroke","fill","viewBox","d","class","rx","id","pivotX","pivotY","Renderers","name","renderers","module","rectangularSvg","renderer","keyMap","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","state","setPlayerPosition","setPlayerState","mountPlayer","keyboard$","swipe$","merge","type","withLatestFrom","visitable","moveInDirection","observeOn","animationFrameScheduler","boardEl","getElementById","boardWrapperEl","ResetEl","options","toLowerCase","registerShortcuts","renderersManager","loadRenderer","then","render","element","lastElementChild","removeChild","removeElementChildren","start","Date","getTime","confetti","canvasConfetti","import","default","console","error","timeDiff","origin","particleCount","setTimeout","mountGame","fromEvent","window","metaKey","ctrlKey","key","preventDefault","stopPropagation","active","activeElement","HTMLElement","undefined","tagName","isContentEditable","isSusceptibleToKeyboard","navigator","maxTouchPoints","msMaxTouchPoints","switchMap","hammer","mc","Manager","Swipe","slice","NEVER","watchSwipe"],"mappings":"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"}