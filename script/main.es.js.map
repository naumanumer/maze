{"version":3,"file":"main.es.js","sources":["../../src/utils/h/svgTags.ts","../../src/utils/h/index.ts","../../src/utils/point.ts","../../src/utils/array.ts","../../src/generators/_pathSetGenerator.ts","../../src/generators/index.ts","../../src/generators/recursiveBackTrack.ts","../../src/generators/aldousBroder.ts","../../src/generators/binaryTree.ts","../../src/generators/eller.ts","../../src/generators/kruskal.ts","../../src/board/cell.ts","../../src/board/board.ts","../../src/board/_.ts","../../src/renderers/rectangularSvg.tsx","../../src/renderers/index.ts","../../src/player/index.ts","../../src/main.ts","../../src/game/index.ts","../../src/browser/element/index.ts","../../src/browser/keyboard/index.ts","../../src/browser/touch/index.ts"],"sourcesContent":["export default [\"circle\", \"defs\", \"ellipse\", \"filter\", \"g\", \"line\", \"path\", \"rect\", \"svg\"]\n","/*\n * Adopted from https://github.com/squidfunk/mkdocs-material/blob/master/src/assets/javascripts/utilities/h/index.ts\n * with additional support for svg elements\n */\n\nimport {JSX as JSXInternal} from \"preact\"\nimport svgTags from \"./svgTags\";\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes =\n  & JSXInternal.HTMLAttributes\n  & JSXInternal.SVGAttributes\n  & Record<string, any>\n\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nfunction appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory\n *\n * @param tag - HTML tag\n * @param attributes - HTML attributes\n * @param children - Child elements\n *\n * @returns Element\n */\nexport function h(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(attr, attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(attr, \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n\n\n/* This override is necessary for types to work */\nexport declare namespace h {\n  namespace JSX {\n    type Element = HTMLElement\n    type IntrinsicElements = JSXInternal.IntrinsicElements\n  }\n}\n","export interface Position {\n  readonly x: number;\n  readonly y: number;\n}\n\n/**\n * Convert a position (2d) to linear index\n */\nexport function positionToIndex(position: Position, width: number): number {\n  return position.y * width + position.x;\n}\n\nexport function stringifyPosition(position: Position) {\n  return `${position.x}-${position.y}`;\n}\n","export function shuffle(array: any[]) {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import {Cell} from \"../board\";\nimport {stringifyPosition} from \"../utils\";\n\nexport type PathSet = Record<string, Cell>;\n\nexport class PathSetGenerator {\n  protected getSetFromCell(cell: Cell, pathSets: PathSet[]): PathSet | undefined {\n    for (let set of pathSets) {\n      if (set[stringifyPosition(cell.position)]) {\n        return set;\n      }\n    }\n  }\n\n  protected joinCellSets(cell1: Cell, cell2: Cell, pathSets: PathSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    if (!set1 && !set2) {\n      pathSets.push({\n        [stringifyPosition(cell1.position)]: cell1,\n        [stringifyPosition(cell2.position)]: cell2,\n      })\n    } else if (set1 == null) {\n      set2[stringifyPosition(cell1.position)] = cell1;\n    } else if (set2 == null) {\n      set1[stringifyPosition(cell2.position)] = cell2;\n    } else {\n      Object.assign(set1, set2);\n      const i = pathSets.indexOf(set2);\n      pathSets.splice(i, 1);\n    }\n  }\n\n  protected isFromSameSet(cell1: Cell, cell2: Cell, pathSets: PathSet[]) {\n    const set1 = this.getSetFromCell(cell1, pathSets);\n    const set2 = this.getSetFromCell(cell2, pathSets);\n\n    return !!set1 && !!set2 && set1 == set2;\n  }\n}\n","import RecursiveBacktrack from \"./recursiveBackTrack\";\nimport AldousBroder from \"./aldousBroder\";\nimport BinaryTree from \"./binaryTree\";\nimport Eller from \"./eller\";\nimport Kruskal from \"./kruskal\";\n\nexport * from './types';\n\nexport const Generators = {\n  recursiveBackTrack: new RecursiveBacktrack(),\n  AldousBroder: new AldousBroder(),\n  BinaryTree: new BinaryTree(),\n  Eller: new Eller(),\n  Kruskal: new Kruskal(),\n}\n","import {Board, Cell, RectangularDirection} from '../board';\nimport {Generator} from \"./types\";\nimport {stringifyPosition} from \"../utils\";\n\n/**\n * Depth first recursive backtrack maze generation algorithm\n * https://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n *\n * Generates long dead ends making the solution little difficult\n */\nexport default class RecursiveBacktrack implements Generator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    const visitedCells = new Set<string>();\n    const randomCell = board.getRandomCell();\n\n    this.visitCell(randomCell, visitedCells, board);\n    return board;\n  }\n\n  visitCell(cell: Cell, visitedCells: Set<string>, board: Board) {\n    visitedCells.add(stringifyPosition(cell.position));\n    const neighbourCells = Array.from(board.getNeighbourCells(cell.position).values());\n\n    while (neighbourCells.length !== 0) {\n      // select a random neighbour\n      const i = Math.round(Math.random() * (neighbourCells.length - 1));\n      const randomCell = neighbourCells[i];\n\n      // if random neighbour is not already visited remove wall between\n      // random neighbour and current cell and recursively visit that neighbour\n      if (!visitedCells.has(stringifyPosition(randomCell.position))) {\n        board.removeInterWall(cell.position, randomCell.position);\n        this.visitCell(randomCell, visitedCells, board);\n      }\n\n      // after visit remove random neighbour from neighbourCells\n      neighbourCells.splice(i, 1);\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {Generator} from \"./types\";\nimport {stringifyPosition} from \"../utils\";\n\n/**\n * https://weblog.jamisbuck.org/2011/1/17/maze-generation-aldous-broder-algorithm\n */\nexport default class AldousBroder implements Generator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    // select a random cell and start from that cell\n    let currentCell = board.getRandomCell();\n    const visitedCells = new Set<string>();\n    visitedCells.add(stringifyPosition(currentCell.position));\n\n    let movingTowards;\n\n    while (visitedCells.size < board.size.height * board.size.width) {\n      const cellNeighbours = Array.from(board.getNeighbourCells(currentCell.position).values());\n\n      const unvisitedNeighbours = cellNeighbours.filter((cell) => {\n        return !visitedCells.has(stringifyPosition(cell.position));\n      })\n\n      // If there are some unvisited neighbours choose any random neighbour and visit it\n      if (unvisitedNeighbours.length > 0) {\n        let randomCell = cellNeighbours[Math.round((cellNeighbours.length - 1) * Math.random())];\n        if (!visitedCells.has(stringifyPosition(randomCell.position))) {\n          board.removeInterWall(randomCell.position, currentCell.position)\n          visitedCells.add(stringifyPosition(randomCell.position));\n          movingTowards = null;\n        }\n\n        currentCell = randomCell;\n      } else {\n        // else just find random unvisited cell and move towards that cell\n        // until you hit some cell which has some unvisited neighbours\n        // NOTE: its not from actual algorithm but doing make this algorithm to always end in finite time\n\n        if (!movingTowards) {\n          const unvisitedCells = board.cells.filter((cell) => {\n            return !visitedCells.has(stringifyPosition(cell.position));\n          });\n\n          movingTowards = unvisitedCells[Math.round((unvisitedCells.length - 1) * Math.random())]\n        }\n\n        let dx = Math.sign(movingTowards.position.x - currentCell.position.x);\n        let dy = dx === 0 ? Math.sign(movingTowards.position.y - currentCell.position.y) : 0;\n        currentCell = board.getCell({x: currentCell.position.x + dx, y: currentCell.position.y + dy});\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {Generator} from \"./types\";\n\n/**\n * http://weblog.jamisbuck.org/2011/2/1/maze-generation-binary-tree-algorithm\n */\nexport default class BinaryTree implements Generator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const topBias = Math.random() > 0.5;\n    const rightBias = Math.random() > 0.5;\n\n    for (let currentCell of board.cells) {\n      let neighbourCells = Array.from(board.getNeighbourCells(currentCell.position).values());\n      neighbourCells = neighbourCells.filter((cell) => {\n        const dir = board.getRelativeDirection(currentCell.position, cell.position);\n\n        return (rightBias && dir == RectangularDirection.LEFT) ||\n          (!rightBias && dir == RectangularDirection.RIGHT) ||\n          (topBias && dir == RectangularDirection.DOWN) ||\n          (!topBias && dir == RectangularDirection.UP);\n      });\n\n      if (neighbourCells.length > 0) {\n        const randomCell = neighbourCells[Math.round((neighbourCells.length - 1) * Math.random())];\n        board.removeInterWall(randomCell.position, currentCell.position)\n      }\n    }\n\n    return board;\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {Generator} from \"./types\";\nimport {shuffle, stringifyPosition} from \"../utils\";\nimport {PathSet, PathSetGenerator} from \"./_pathSetGenerator\";\n\n/**\n * https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport default class Eller extends PathSetGenerator implements Generator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: PathSet[] = [];\n\n    for (let x = 0; x < board.size.width; x++) {\n      const cell = board.getCell({x, y: 0});\n      pathSets.push({\n        [stringifyPosition(cell.position)]: cell,\n      });\n    }\n\n    for (let y = 0; y < board.size.height - 1; y++) {\n      this.visitRow(y, false, board, pathSets);\n      this.visitNextRow(y, board, pathSets);\n    }\n\n    this.visitRow(board.size.height - 1, true, board, pathSets);\n    return board;\n  }\n\n  private visitRow(index: number, mergeAll: boolean, board: Board, pathSets: PathSet[]) {\n    for (let x = 1; x < board.size.width; x++) {\n      const cell1 = board.getCell({y: index, x: x - 1});\n      const cell2 = board.getCell({y: index, x});\n\n      if (this.isFromSameSet(cell1, cell2, pathSets)) {\n        continue;\n      }\n\n      if (Math.random() > 0.5 || mergeAll) {\n        board.removeInterWall(cell1.position, cell2.position);\n        this.joinCellSets(cell1, cell2, pathSets);\n      } else if (this.getSetFromCell(cell1, pathSets) == null) {\n        pathSets.push({\n          [stringifyPosition(cell1.position)]: cell1,\n        })\n      } else if (this.getSetFromCell(cell2, pathSets) == null) {\n        pathSets.push({\n          [stringifyPosition(cell2.position)]: cell2,\n        })\n      }\n    }\n  }\n\n  private visitNextRow(index: number, board: Board, pathSets: PathSet[]) {\n    for (let set of pathSets) {\n      let setCells = Object.entries(set)\n        .filter(([key, cell]) => {\n          return cell.position.y === index;\n        })\n        .map(([key, cell]) => cell);\n\n      setCells = shuffle(setCells);\n      let n = 1 + Math.round(Math.random() * (setCells.length - 1));\n      for (let i = 0; i < n; i++) {\n        const cell = setCells[i];\n        const nextCell = board.getCell({x: cell.position.x, y: cell.position.y + 1});\n        // const previousCell = cell.position.x > 0 ? board.getCell({\n        //   x: cell.position.x - 1,\n        //   y: cell.position.y + 1\n        // }) : null;\n        //\n        // if (previousCell && this.isFromSameSet(cell, previousCell, pathSets)) {\n        //   continue;\n        // }\n\n        board.removeInterWall(cell.position, nextCell.position);\n        set[stringifyPosition(nextCell.position)] = nextCell;\n      }\n    }\n  }\n}\n","import {Board, RectangularDirection} from '../board';\nimport {Generator} from \"./types\";\nimport {stringifyPosition} from \"../utils\";\nimport {PathSet, PathSetGenerator} from \"./_pathSetGenerator\";\n\n/**\n * https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\n */\nexport default class Kruskal extends PathSetGenerator implements Generator {\n  generate(board: Board): Board {\n    board = board.clone();\n\n    // open top-left and bottom-right walls\n    board.cells[0].removeWall(RectangularDirection.LEFT);\n    board.cells[board.cells.length - 1].removeWall(RectangularDirection.RIGHT);\n\n    const pathSets: PathSet[] = [];\n\n    for (let cell of board.cells) {\n      pathSets.push({\n        [stringifyPosition(cell.position)]: cell,\n      });\n    }\n\n    while (pathSets.length > 1) {\n      const randomCell = board.getRandomCell();\n      const neighbours = Array.from(board.getNeighbourCells(randomCell.position).values());\n      const randomNeighbour = neighbours[Math.round((neighbours.length - 1) * Math.random())]\n\n      if (this.isFromSameSet(randomCell, randomNeighbour, pathSets)) continue;\n\n      board.removeInterWall(randomCell.position, randomNeighbour.position);\n      this.joinCellSets(randomCell, randomNeighbour, pathSets);\n    }\n\n    return board;\n  }\n}\n","import {Position} from \"../utils\";\n\nexport const enum RectangularDirection {\n  LEFT = 'left',\n  RIGHT = 'right',\n  UP = 'up',\n  DOWN = 'down',\n}\n\nexport const OpposingRectangularDirection = {\n  [RectangularDirection.LEFT]: RectangularDirection.RIGHT,\n  [RectangularDirection.RIGHT]: RectangularDirection.LEFT,\n  [RectangularDirection.UP]: RectangularDirection.DOWN,\n  [RectangularDirection.DOWN]: RectangularDirection.UP,\n};\n\nexport class Cell {\n  public readonly walls: Map<RectangularDirection, boolean>;\n\n  constructor(public readonly position: Position) {\n    this.walls = new Map<RectangularDirection, boolean>();\n    this.setAllWalls();\n  }\n\n  setAllWalls() {\n    this.setWall(RectangularDirection.UP);\n    this.setWall(RectangularDirection.RIGHT);\n    this.setWall(RectangularDirection.DOWN);\n    this.setWall(RectangularDirection.LEFT);\n  }\n\n  removeAllWalls() {\n    this.removeWall(RectangularDirection.UP);\n    this.removeWall(RectangularDirection.RIGHT);\n    this.removeWall(RectangularDirection.DOWN);\n    this.removeWall(RectangularDirection.LEFT);\n  }\n\n  setWall(dir: RectangularDirection) {\n    this.walls.set(dir, true);\n  }\n\n  removeWall(dir: RectangularDirection) {\n    this.walls.set(dir, false);\n  }\n\n  hasWall(dir: RectangularDirection): boolean {\n    return this.walls.get(dir);\n  }\n\n  clone() {\n    const cell = new Cell(this.position);\n    for (const [dir, hasWall] of this.walls.entries()) {\n      cell.walls.set(dir, hasWall);\n    }\n    return cell;\n  }\n}\n","import {Cell, OpposingRectangularDirection, RectangularDirection} from './cell';\nimport {Position, positionToIndex, Size} from \"../utils\";\n\nexport class Board {\n  public readonly cells: Array<Cell>;\n  public readonly size: Size;\n\n  constructor(width: number, height: number) {\n    this.size = {height, width};\n    this.cells = [];\n    this.initCells();\n  }\n\n  private initCells() {\n    for (let y = 0; y < this.size.height; y++) {\n      for (let x = 0; x < this.size.width; x++) {\n        this.cells.push(new Cell({x, y}));\n      }\n    }\n  }\n\n  getRandomCell(): Cell {\n    return this.cells[Math.round(Math.random() * (this.cells.length - 1))];\n  }\n\n  getCell(position: Position): Cell {\n    return this.cells[positionToIndex(position, this.size.width)];\n  }\n\n  getNeighbourCells(position: Position, visitableOnly: boolean = false): Map<RectangularDirection, Cell> {\n    let neighbours = new Map<RectangularDirection, Cell>(),\n      index = positionToIndex(position, this.size.width);\n\n    if (index >= this.size.width) {\n      const cell = this.cells[index - this.size.width];\n      neighbours.set(RectangularDirection.UP, cell);\n    }\n\n    if ((index + 1) % this.size.width != 0) {\n      const cell = this.cells[index + 1];\n      neighbours.set(RectangularDirection.RIGHT, cell);\n    }\n\n    if (index < this.cells.length - this.size.width) {\n      const cell = this.cells[index + this.size.width];\n      neighbours.set(RectangularDirection.DOWN, cell);\n    }\n\n    if (index % this.size.width != 0) {\n      const cell = this.cells[index - 1];\n      neighbours.set(RectangularDirection.LEFT, cell);\n    }\n\n    if (visitableOnly) {\n      const visitableNeighbours = Array.from(neighbours.entries())\n        .filter(([dir, cell]) => {\n          return !this.hasInterWall(cell.position, position);\n        });\n\n      neighbours = new Map(visitableNeighbours);\n    }\n\n    return neighbours;\n  }\n\n  getNeighbourCell(position: Position, direction: RectangularDirection): Cell {\n    const cells = this.getNeighbourCells(position);\n    return cells.get(direction);\n  }\n\n  getRelativeDirection(cell1: Position, cell2: Position): RectangularDirection {\n    if (cell1.y === cell2.y + 1) {\n      return RectangularDirection.UP;\n    }\n    if (cell1.x === cell2.x - 1) {\n      return RectangularDirection.RIGHT;\n    }\n    if (cell1.x === cell2.x + 1) {\n      return RectangularDirection.LEFT;\n    }\n    if (cell1.y === cell2.y - 1) {\n      return RectangularDirection.DOWN;\n    }\n    throw `'${cell1}' and '${cell2}' are not neighbours`;\n  }\n\n  removeInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).removeWall(relativeWallDirection);\n    this.getCell(cell2).removeWall(opposingWallDirection);\n  }\n\n  addInterWall(cell1: Position, cell2: Position): void {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    this.getCell(cell1).setWall(relativeWallDirection);\n    this.getCell(cell2).setWall(opposingWallDirection);\n  }\n\n  hasInterWall(cell1: Position, cell2: Position): boolean {\n    const relativeWall = this.getRelativeDirection(cell1, cell2);\n    const opposingWall = OpposingRectangularDirection[relativeWall];\n    return this.getCell(cell1).hasWall(relativeWall) && this.getCell(cell2).hasWall(opposingWall);\n  }\n\n  isConnected(cell1: Position, cell2: Position): Boolean {\n    const relativeWallDirection = this.getRelativeDirection(cell1, cell2);\n    const opposingWallDirection = OpposingRectangularDirection[relativeWallDirection];\n    return this.getCell(cell1).hasWall(relativeWallDirection) && this.getCell(cell2).hasWall(opposingWallDirection);\n  }\n\n  hasWall(position: Position, direction: RectangularDirection) {\n    return this.getCell(position).hasWall(direction);\n  }\n\n  clone() {\n    const board = new Board(this.size.width, this.size.height);\n    for (let i = 0; i < board.cells.length; i++) {\n      board.cells[i] = this.cells[i].clone();\n    }\n    return board;\n  }\n}\n","import {BehaviorSubject, Observable} from \"rxjs\";\nimport {Board} from \"./board\";\nimport {concatMap, filter, share} from \"rxjs/operators\";\nimport {Generator} from \"../generators\";\nimport {Position} from \"../utils\";\n\n/*--------------\n * Interfaces\n *-------------- */\n\nexport interface BoardOptions {\n  width: number;\n  height: number;\n  generator: Generator,\n}\n\n/*-------------------\n * Reactive instance\n *------------------- */\n\nconst board$ = new BehaviorSubject<BoardOptions>(null)\n\n\n/*-------------------\n * Actions\n *------------------- */\n\n/**\n * Reset board with last board settings\n */\nexport function resetBoard() {\n  board$.next(board$.getValue());\n}\n\n/**\n * generate a new board with given board `options`\n */\nexport function newBoard(options: BoardOptions) {\n  board$.next(options);\n}\n\n/*-------------------\n * Helpers\n *------------------- */\n\n/**\n * Checks if the given position is last position of cell\n * useful to test game win state\n */\nexport function isLastCell({x, y}: Position): boolean {\n  const {width, height} = board$.getValue();\n  return x === width - 1 && y === height - 1;\n}\n\n/*-------------------\n * Functions\n *------------------- */\n\nexport function mountBoard(): Observable<Board> {\n  return board$\n    .pipe(\n      filter(ev => !!ev),\n      concatMap(async ({width, height, generator}) => {\n        let board = new Board(width, height);\n        return generator.generate(board);\n      }),\n      share(),\n    );\n}\n","import {h} from \"../utils\";\nimport {IRenderer} from \"./types\";\nimport {Board, Cell, RectangularDirection} from \"../board\";\nimport {Observable} from \"rxjs\";\nimport {Player} from \"../player\";\n\nexport default class RectangularSvg implements IRenderer {\n  /*\n   * Some rendering options\n   * should some easier way to set them\n   */\n  public cellSize = 30;\n  public lineWidth = 2;\n  public playerPadding = 7;\n\n  constructor() {\n    // setting a css variable for wall animation\n    let root = document.documentElement;\n    root.style.setProperty('--cell-size', this.cellSize + 'px');\n  }\n\n  /**\n   * Renders game board to svg\n   *\n   * The idea is renderer will be initialized only once\n   * and then render function will be called for each new board,\n   * while renderer will take care of player changes without explicitly\n   * rerendering of board.\n   *\n   * @param board individual board snapshot\n   * @param player$ Observable of player position changes\n   */\n  render(board: Board, player$: Observable<Player>): HTMLElement {\n    const width = this.cellSize * (board.size.width + 2) + this.lineWidth;\n    const height = this.cellSize * (board.size.height + 2) + this.lineWidth;\n    const playerEl = this.renderPlayer();\n\n    // listen to player changes and update player on board\n    player$\n      .subscribe(({position}) => {\n        const [x, y] = [position.x, position.y]\n          .map((e) => (this.cellSize * e) + this.playerPadding + this.cellSize);\n\n        playerEl.setAttribute('x', x + '');\n        playerEl.setAttribute('y', y + '');\n      })\n\n    // render path definition string for each cell\n    // and join them to create single path string\n    // for whole board\n    let path = board.cells.map((value) => {\n      return this.renderCell(value, board.size);\n    }).join('');\n\n    return (\n      <svg stroke=\"currentColor\" fill=\"none\" width={width} height={height} viewBox={`0 0 ${width} ${height}`}>\n        {playerEl}\n        <path d={path} class=\"maze-wall\" stroke-width={this.lineWidth} stroke-linecap=\"round\"/>\n      </svg>\n    );\n  }\n\n  /**\n   * Renders player as svg rect\n   */\n  renderPlayer() {\n    const size = this.cellSize - (this.playerPadding * 2);\n    return <rect width={size} height={size} fill=\"currentColor\"\n                 class=\"text-blue-500\"\n                 stroke-width=\"0\" rx=\"3\" id=\"player\"\n                 x={1 + this.playerPadding + this.cellSize} y={1 + this.playerPadding + this.cellSize}/>;\n  }\n\n  /**\n   * Renders a single cell walls to svg path string\n   * @param cell cell to render\n   * @param size board size\n   */\n  renderCell(cell: Cell, size: { width: number, height: number }): string {\n    const pivotX = cell.position.x * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    const pivotY = cell.position.y * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    let path = '';\n\n    if (cell.hasWall(RectangularDirection.UP)) {\n      // Top wall\n      path += `M${pivotX},${pivotY}H${pivotX + this.cellSize}`;\n    }\n\n    if (cell.hasWall(RectangularDirection.LEFT)) {\n      // Left wall\n      path += `M${pivotX},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.x + 1 === size.width && cell.hasWall(RectangularDirection.RIGHT)) {\n      // Right Wall\n      path += `M${pivotX + this.cellSize},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.y + 1 === size.height) {\n      // Bottom Wall\n      path += `M${pivotX},${pivotY + this.cellSize}H${pivotX + this.cellSize}`;\n    }\n\n    return path;\n  }\n}\n","import {IRenderer} from \"./types\";\nimport RectangularSvg from './rectangularSvg';\n\nexport enum Renderers {\n  rectangularSvg\n}\n\nclass RendererManager {\n  private renderers = new Map<Renderers, IRenderer>();\n\n  async loadRenderer(name: Renderers) {\n    if (this.renderers.has(name)) {\n      return this.renderers.get(name);\n    }\n\n    // Just easiest work around for rollup dynamic imports\n    let module;\n    switch (name) {\n      case Renderers.rectangularSvg:\n        module = RectangularSvg;\n        break;\n    }\n\n    const renderer = new module();\n    this.renderers.set(name, renderer);\n    return renderer;\n  }\n}\n\nexport default new RendererManager();\n","import {animationFrameScheduler, BehaviorSubject, merge, Observable} from \"rxjs\";\nimport {Keyboard, Swipe} from \"../browser\";\nimport {Board, RectangularDirection} from \"../board\";\nimport {Position} from \"../utils\";\nimport {filter, map, observeOn, withLatestFrom} from \"rxjs/operators\";\n\n/*------------------\n * Types\n *------------------*/\n\nexport interface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  board$: Observable<Board>;\n}\n\nexport interface Player {\n  state: 'active' | 'inactive' | 'hidden';\n  position: Position;\n}\n\nexport interface Control {\n  dir: RectangularDirection\n}\n\n/*------------------\n * Maps\n *------------------*/\n\nexport const keyMap = {\n  'ArrowRight': RectangularDirection.RIGHT,\n  'ArrowLeft': RectangularDirection.LEFT,\n  'ArrowUp': RectangularDirection.UP,\n  'ArrowDown': RectangularDirection.DOWN,\n}\n\n/*--------------------\n * Reactive instance\n *--------------------*/\n\nconst player$ = new BehaviorSubject<Player>({\n  state: 'active',\n  position: {x: 0, y: 0}\n});\n\n\n/*--------------------\n * Actions\n *--------------------*/\n\n/**\n * Set player Position\n */\nexport function setPlayerPosition(position: Position) {\n  const {state} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Set player Position\n */\nexport function setPlayerState(state: 'active' | 'inactive' | 'hidden') {\n  const {position} = player$.getValue();\n  player$.next({\n    state,\n    position,\n  })\n}\n\n/**\n * Move player in given direction\n */\nexport function moveInDirection(dir: RectangularDirection, board: Board) {\n  let {position: {x, y}} = player$.getValue();\n\n  // continue to moving player in the direction until cell is a passage\n  do {\n    if (dir === 'right' && x < (board.size.width - 1)) {\n      x++;\n    } else if (dir === 'left' && x > 0) {\n      x--;\n    } else if (dir === 'up' && y > 0) {\n      y--;\n    } else if (dir === 'down' && y < (board.size.height - 1)) {\n      y++;\n    }\n\n    const visitable = board.getNeighbourCells({x, y}, true);\n    if (!visitable.has(dir) || visitable.size > 2) {\n      break;\n    }\n  } while (true);\n\n  setPlayerPosition({x, y});\n}\n\n/*--------------------\n * Functions\n *--------------------*/\n\n/**\n * Mount player to game logic\n *\n * returns a observable player\n */\nexport function mountPlayer(\n  {keyboard$, swipe$, board$}: MountOptions\n): Observable<Player> {\n\n  // reset player whenever new board is emitted\n  board$.subscribe(() => {\n    const {position: {x, y}} = player$.getValue();\n    if (x !== 0 || y !== 0) {\n      setPlayerPosition({x: 0, y: 0})\n    }\n  })\n\n  // combine touch and keyboard events\n  const control$: Observable<Control> = merge(\n    keyboard$,\n    swipe$,\n  ).pipe(\n    map((dir) => {\n      if ((dir as Keyboard).type) {\n        // @ts-ignore\n        return {dir: keyMap[dir.type]}\n      }\n      return dir as Swipe;\n    })\n  )\n\n  control$\n    .pipe(\n      withLatestFrom(board$),\n      // don't move player if there is a wall in control direction\n      // or player is not active\n      filter(([{dir}, board]) => {\n        const {position: {x, y}, state} = player$.getValue();\n        return state === 'active' && !board.hasWall({x, y}, dir);\n      })\n    )\n    .subscribe(([{dir}, board]) => {\n      moveInDirection(dir, board)\n    });\n\n  // use animationFrameScheduler to ensure smooth animations\n  return player$.pipe(\n    observeOn(animationFrameScheduler)\n  )\n}\n","import {watchKeyboard, watchSwipe} from \"./browser\";\nimport {Generators} from './generators';\nimport {newBoard, resetBoard} from \"./board\";\nimport {fromEvent} from \"rxjs\";\nimport {mountGame} from \"./game\";\n\n/*\n * References to some required document elements\n * Technically this should be done after DOM Content Loaded\n * But for some reason its working :)\n */\nconst boardEl = document.getElementById('board');\nconst boardWrapperEl = document.getElementById('boardWrapper');\nconst ResetEl = document.getElementById('reset');\n\n\n/* initialize all the observables */\nconst keyboard$ = watchKeyboard();\nconst swipe$ = watchSwipe(boardWrapperEl);\n\nmountGame({keyboard$, swipe$, boardEl});\n\n/*\n * Initialize board with initial options.\n * Every other price of the board depends on\n * some non-null value of board option\n */\nnewBoard({\n  height: 15,\n  width: 15,\n  generator: Generators.recursiveBackTrack,\n});\n\n\n/* Bind events with buttons */\nfromEvent(ResetEl, 'click')\n  .subscribe(resetBoard);\n","import {Size} from \"../utils\";\nimport {Generator} from \"../generators\";\nimport renderersManager, {Renderers} from \"../renderers\";\nimport {Observable} from \"rxjs\";\nimport {Keyboard} from \"../browser/keyboard\";\nimport {Swipe} from \"../browser/touch\";\nimport {isLastCell, mountBoard, resetBoard} from \"../board\";\nimport {mountPlayer, setPlayerPosition, setPlayerState} from \"../player\";\nimport {removeElementChildren} from \"../browser/element\";\nimport {filter} from \"rxjs/operators\";\nimport {default as canvasConfetti} from \"canvas-confetti\";\n\nexport interface GameOptions {\n  size: Size;\n  generator: Generator;\n  renderer: Renderers;\n  interactive: boolean;\n  showPlayer: boolean;\n}\n\ninterface MountOptions {\n  keyboard$: Observable<Keyboard>;\n  swipe$: Observable<Swipe>;\n  boardEl: HTMLElement;\n}\n\n/**\n * Handle keyboard shortcuts\n */\nfunction registerShortcuts(keyboard$: Observable<Keyboard>) {\n  keyboard$.subscribe(({type}) => {\n    /* 'r' to reset game */\n    if (type.toLowerCase() === 'r') {\n      resetBoard();\n    }\n  })\n}\n\nexport function mountGame({keyboard$, swipe$, boardEl}: MountOptions) {\n  registerShortcuts(keyboard$);\n\n  const board$ = mountBoard();\n  const player$ = mountPlayer({keyboard$, board$, swipe$});\n\n  /* render board whenever new board is emitted */\n  board$\n    .subscribe((board) => {\n      setPlayerState('active');\n      renderersManager.loadRenderer(Renderers.rectangularSvg).then((render) => {\n        removeElementChildren(boardEl);\n        boardEl.appendChild(\n          render.render(board, player$)\n        );\n      })\n    });\n\n  player$\n    .pipe(\n      filter(({position, state}) => isLastCell(position) && state === 'active'),\n    )\n    .subscribe(async ({position: {x, y}}) => {\n      const start = new Date().getTime();\n      setPlayerState('inactive');\n\n      let confetti: typeof canvasConfetti;\n      try {\n        const canvasConfetti = await import('canvas-confetti');\n        confetti = canvasConfetti.default;\n      } catch (e) {\n        console.error(e);\n      }\n\n      const timeDiff = new Date().getTime() - start;\n      if (timeDiff >= 250) {\n        setPlayerPosition({x: x + 1, y});\n\n        if (confetti)\n          confetti({origin: {y: 0.8}, particleCount: 100}).then();\n      } else {\n        setTimeout(() => {\n          setPlayerPosition({x: x + 1, y});\n          if (confetti)\n            confetti({origin: {y: 0.8}, particleCount: 100}).then();\n        }, 250 - timeDiff);\n      }\n    });\n}\n","/**\n * Retrieve the currently active element\n *\n * @returns Element or nothing\n */\nexport function getActiveElement(): HTMLElement | undefined {\n  return document.activeElement instanceof HTMLElement\n    ? document.activeElement\n    : undefined\n}\n\n\n/**\n * Remove all the children of given element\n */\nexport function removeElementChildren(element: HTMLElement): void {\n  while (element.lastElementChild) {\n    element.removeChild(element.lastElementChild);\n  }\n}\n","import {fromEvent, Observable} from \"rxjs\";\nimport {filter, map, share} from \"rxjs/operators\";\nimport {getActiveElement} from \"../element\";\n\n/**\n * Keyboard\n */\nexport interface Keyboard {\n  type: string                         /* Key type */\n  claim(): void                        /* Key claim */\n}\n\n/**\n * Check whether an element may receive keyboard input\n *\n * @param el - Element\n *\n * @returns Test result\n */\nfunction isSusceptibleToKeyboard(el: HTMLElement): boolean {\n  switch (el.tagName) {\n    /* Form elements */\n    case \"INPUT\":\n    case \"SELECT\":\n    case \"TEXTAREA\":\n      return true\n\n    /* Everything else */\n    default:\n      return el.isContentEditable\n  }\n}\n\n/**\n * Watch keyboard\n *\n * @returns Keyboard observable\n */\nexport function watchKeyboard(): Observable<Keyboard> {\n  return fromEvent<KeyboardEvent>(window, \"keydown\")\n    .pipe(\n      filter(ev => !(ev.metaKey || ev.ctrlKey)),\n      map(ev => ({\n        type: ev.key,\n        claim() {\n          ev.preventDefault()\n          ev.stopPropagation()\n        }\n      } as Keyboard)),\n      filter(() => {\n        const active = getActiveElement()\n        if (typeof active !== \"undefined\")\n          return !isSusceptibleToKeyboard(active)\n\n        return true\n      }),\n      share(),\n    )\n}\n","import {from, fromEvent, merge, NEVER, Observable} from \"rxjs\";\nimport {map, share, switchMap} from \"rxjs/operators\";\nimport {RectangularDirection} from \"../../board\";\n\nexport interface Swipe {\n  dir: RectangularDirection;\n}\n\n/**\n * Watch swipe events on the given element using hammerjs\n */\nexport function watchSwipe(element = document.documentElement): Observable<Swipe> {\n  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);\n\n  if (!isTouchDevice) {\n    return NEVER;\n  }\n\n  return from(import('hammerjs'))\n    .pipe(\n      switchMap((hammer) => {\n        const mc = new hammer.Manager(element);\n        mc.add(new hammer.Swipe());\n\n        return merge(\n          fromEvent(mc, 'swipeleft'),\n          fromEvent(mc, 'swiperight'),\n          fromEvent(mc, 'swipeup'),\n          fromEvent(mc, 'swipedown'),\n        )\n      }),\n      map(({type}) => {\n        return {dir: type.slice(5)};\n      }),\n      share(),\n    )\n}\n"],"names":["appendChild","el","child","innerHTML","toString","Node","Array","isArray","node","h","tag","attributes","children","svgTags","includes","document","createElementNS","createElement","attr","Object","keys","setAttribute","positionToIndex","position","width","y","x","stringifyPosition","shuffle","array","temporaryValue","randomIndex","currentIndex","length","Math","floor","random","PathSetGenerator","[object Object]","cell","pathSets","set","cell1","cell2","set1","this","getSetFromCell","set2","assign","i","indexOf","splice","push","Generators","recursiveBackTrack","board","clone","cells","removeWall","visitedCells","Set","randomCell","getRandomCell","visitCell","add","neighbourCells","from","getNeighbourCells","values","round","has","removeInterWall","AldousBroder","currentCell","movingTowards","size","height","cellNeighbours","filter","unvisitedCells","dx","sign","dy","getCell","BinaryTree","topBias","rightBias","dir","getRelativeDirection","Eller","visitRow","visitNextRow","index","mergeAll","isFromSameSet","joinCellSets","setCells","entries","key","map","n","nextCell","Kruskal","neighbours","randomNeighbour","OpposingRectangularDirection","left","right","up","down","Cell","walls","Map","setAllWalls","setWall","get","hasWall","Board","initCells","visitableOnly","visitableNeighbours","hasInterWall","direction","relativeWallDirection","opposingWallDirection","relativeWall","opposingWall","board$","BehaviorSubject","resetBoard","next","getValue","isLastCell","mountBoard","pipe","ev","concatMap","async","generator","generate","share","RectangularSvg","documentElement","style","setProperty","cellSize","player$","lineWidth","playerEl","renderPlayer","subscribe","e","playerPadding","path","value","renderCell","join","stroke","fill","viewBox","d","class","rx","id","pivotX","pivotY","Renderers","name","renderers","module","rectangularSvg","renderer","keyMap","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","state","setPlayerPosition","setPlayerState","mountPlayer","keyboard$","swipe$","merge","type","withLatestFrom","visitable","moveInDirection","observeOn","animationFrameScheduler","boardEl","getElementById","boardWrapperEl","ResetEl","options","toLowerCase","registerShortcuts","renderersManager","loadRenderer","then","render","element","lastElementChild","removeChild","removeElementChildren","start","Date","getTime","confetti","canvasConfetti","import","default","console","error","timeDiff","origin","particleCount","setTimeout","mountGame","fromEvent","window","metaKey","ctrlKey","preventDefault","stopPropagation","active","activeElement","HTMLElement","undefined","tagName","isContentEditable","isSusceptibleToKeyboard","navigator","maxTouchPoints","msMaxTouchPoints","switchMap","hammer","mc","Manager","Swipe","slice","NEVER","watchSwipe"],"mappings":"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"}