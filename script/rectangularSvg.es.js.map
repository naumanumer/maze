{"version":3,"file":"rectangularSvg.es.js","sources":["../../node_modules/rxjs/_esm5/internal/operators/skip.js","../../src/utils/h/svgTags.ts","../../src/utils/h/index.ts","../../src/renderers/rectangularSvg.tsx"],"sourcesContent":["/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nvar SkipOperator = /*@__PURE__*/ (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\nvar SkipSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        var _this = _super.call(this, destination) || this;\n        _this.total = total;\n        _this.count = 0;\n        return _this;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber));\n//# sourceMappingURL=skip.js.map\n","export default [\n  \"animate\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"defs\",\n  \"desc\",\n  \"discard\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"foreignObject\",\n  \"g\",\n  \"hatch\",\n  \"hatchpath\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"mesh\",\n  \"meshgradient\",\n  \"meshpatch\",\n  \"meshrow\",\n  \"metadata\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"solidColor\",\n  \"stop\",\n  \"style\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tspan\",\n  \"unknown\",\n  \"use\",\n  \"view\"\n]\n","/*\n * Adopted from https://github.com/squidfunk/mkdocs-material/blob/master/src/assets/javascripts/utilities/h/index.ts\n * with additional support for svg elements\n */\n\nimport {JSX as JSXInternal} from \"preact\"\nimport svgTags from \"./svgTags\";\n\ntype Child =\n  | HTMLElement\n  | Text\n  | string\n  | number\n\ntype Attributes =\n  & JSXInternal.HTMLAttributes\n  & JSXInternal.SVGAttributes\n  & Record<string, any>\n\n\n/**\n * Append a child node to an element\n *\n * @param el - Element\n * @param child - Child node(s)\n */\nfunction appendChild(el: HTMLElement | SVGElement, child: Child | Child[]): void {\n  /* Handle primitive types (including raw HTML) */\n  if (typeof child === \"string\" || typeof child === \"number\") {\n    el.innerHTML += child.toString()\n\n    /* Handle nodes */\n  } else if (child instanceof Node) {\n    el.appendChild(child)\n\n    /* Handle nested children */\n  } else if (Array.isArray(child)) {\n    for (const node of child)\n      appendChild(el, node)\n  }\n}\n\n/**\n * JSX factory\n *\n * @param tag - HTML tag\n * @param attributes - HTML attributes\n * @param children - Child elements\n *\n * @returns Element\n */\nexport function h(\n  tag: string, attributes: Attributes | null, ...children: Child[]\n): HTMLElement | SVGElement {\n  let el;\n\n  /* Handle svg element */\n  if (svgTags.includes(tag)) {\n    el = document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n\n    /* Handle normal html element */\n  } else {\n    el = document.createElement(tag);\n  }\n\n  /* Set attributes, if any */\n  if (attributes) {\n    for (const attr of Object.keys(attributes)) {\n      if (typeof attributes[attr] !== \"boolean\") {\n        el.setAttribute(attr, attributes[attr]);\n      } else if (attributes[attr]) {\n        el.setAttribute(attr, \"\");\n      }\n    }\n  }\n\n  /* Append child nodes */\n  for (const child of children) {\n    appendChild(el, child)\n  }\n\n  /* Return element */\n  return el\n}\n\n\n/* This override is necessary for types to work */\nexport declare namespace h {\n  namespace JSX {\n    type Element = HTMLElement\n    type IntrinsicElements = JSXInternal.IntrinsicElements\n  }\n}\n","import {h} from \"../utils\";\nimport {IRenderer} from \"./types\";\nimport {Board, Cell, ISize, RectangularDirection} from \"../board\";\nimport {Observable} from \"rxjs\";\nimport {Player} from \"../player\";\nimport {skip} from \"rxjs/operators\";\n\nexport default class RectangularSvg implements IRenderer {\n  /*\n   * Some rendering options\n   * should some easier way to set them\n   */\n  public cellSize = 30;\n  public lineWidth = 2;\n  public playerPadding = 7;\n\n  constructor() {\n    // setting a css variable for wall animation\n    let root = document.documentElement;\n    root.style.setProperty('--cell-size', this.cellSize + 'px');\n  }\n\n  /**\n   * Renders game board to svg\n   *\n   * The idea is renderer will be initialized only once\n   * and then render function will be called for each new board,\n   * while renderer will take care of player changes without explicitly\n   * rerendering of board.\n   *\n   * @param board individual board snapshot\n   * @param player$ Observable of player position changes\n   */\n  render(board: Board, player$: Observable<Player>): HTMLElement {\n    const width = this.cellSize * (board.size.width + 2) + this.lineWidth;\n    const height = this.cellSize * (board.size.height + 2) + this.lineWidth;\n    const playerEl = this.renderPlayer();\n\n    // listen to player changes and update player on board\n    player$\n      .pipe(skip(1))\n      .subscribe(({position}) => {\n        const [x, y] = [position.x, position.y]\n          .map((e) => (this.cellSize * e) + this.playerPadding + this.cellSize);\n\n        playerEl.setAttribute('x', x + '');\n        playerEl.setAttribute('y', y + '');\n      })\n\n    // render path definition string for each cell\n    // and join them to create single path string\n    // for whole board\n    let path = board.cells.map((value) => {\n      return this.renderCell(value, board.size);\n    }).join('');\n\n    return (\n      <svg stroke=\"currentColor\" fill=\"none\" width={width} height={height} viewBox={`0 0 ${width} ${height}`}>\n        {playerEl}\n        <path d={path} class=\"maze-wall\" stroke-width={this.lineWidth} stroke-linecap=\"round\"/>\n      </svg>\n    );\n  }\n\n  /**\n   * Renders player as svg rect\n   */\n  renderPlayer() {\n    const size = this.cellSize - (this.playerPadding * 2);\n    return <rect width={size} height={size} fill=\"currentColor\"\n                 class=\"text-blue-500\"\n                 stroke-width=\"0\" rx=\"3\" id=\"player\"\n                 x={1 + this.playerPadding + this.cellSize} y={1 + this.playerPadding + this.cellSize}/>;\n  }\n\n  /**\n   * Renders a single cell walls to svg path string\n   * @param cell cell to render\n   * @param size board size\n   */\n  renderCell(cell: Cell, size: ISize): string {\n    const pivotX = cell.position.x * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    const pivotY = cell.position.y * this.cellSize + (this.lineWidth / 2) + this.cellSize;\n    let path = '';\n\n    if (cell.hasWall(RectangularDirection.UP)) {\n      // Top wall\n      path += `M${pivotX},${pivotY}H${pivotX + this.cellSize}`;\n    }\n\n    if (cell.hasWall(RectangularDirection.LEFT)) {\n      // Left wall\n      path += `M${pivotX},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.x + 1 === size.width && cell.hasWall(RectangularDirection.RIGHT)) {\n      // Right Wall\n      path += `M${pivotX + this.cellSize},${pivotY}V${pivotY + this.cellSize}`;\n    }\n\n    if (cell.position.y + 1 === size.height) {\n      // Bottom Wall\n      path += `M${pivotX},${pivotY + this.cellSize}H${pivotX + this.cellSize}`;\n    }\n\n    return path;\n  }\n}\n"],"names":["SkipOperator","total","this","prototype","call","subscriber","source","subscribe","SkipSubscriber","_super","destination","_this","count","tslib_1.__extends","_next","x","next","Subscriber","appendChild","el","child","innerHTML","toString","Node","Array","isArray","node","h","tag","attributes","children","svgTags","includes","document","createElementNS","createElement","attr","Object","keys","setAttribute","[object Object]","documentElement","style","setProperty","cellSize","board","player$","width","size","lineWidth","height","playerEl","renderPlayer","pipe","lift","position","y","map","e","playerPadding","path","cells","value","renderCell","join","stroke","fill","viewBox","d","class","rx","id","cell","pivotX","pivotY","hasWall"],"mappings":"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"}